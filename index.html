<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SimpleSynth</title>
    <meta
        name="description"
        content="A web-based synthesizer for real-time sound generation with harmonics, reverb, and waveform visualization."
    />
    <meta name="theme-color" content="#f8f4ec" />
    <link rel="canonical" href="https://workmanl.github.io/SimpleSynth/" />
    <link rel="icon" href="favicon.svg" type="image/svg+xml" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Orbitron:wght@400;600;700&family=Rajdhani:wght@400;500;600&display=swap"
        rel="stylesheet"
    />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="SimpleSynth" />
    <meta
        property="og:description"
        content="A web-based synthesizer for real-time sound generation with harmonics, reverb, and waveform visualization."
    />
    <meta property="og:url" content="https://workmanl.github.io/SimpleSynth/" />
    <meta property="og:site_name" content="SimpleSynth" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="SimpleSynth" />
    <meta
        name="twitter:description"
        content="A web-based synthesizer for real-time sound generation with harmonics, reverb, and waveform visualization."
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <style>

        :root {
            --lcars-bg: #171a1e;
            --lcars-panel: #22262b;
            --lcars-panel-strong: #2b3036;
            --lcars-ink: #e6eaef;
            --lcars-muted: #9aa3ad;
            --lcars-orange: #b7bdc5;
            --lcars-peach: #a8b0ba;
            --lcars-lilac: #8f98a3;
            --lcars-blue: #7f8b96;
            --lcars-teal: #8b949e;
            --lcars-yellow: #c7cdd4;
            --lcars-shadow: 0 18px 30px rgba(0, 0, 0, 0.45);
            --apollo-metal: #c2c7ce;
            --apollo-gunmetal: #2a2e34;
            --apollo-led-green: #59f0a1;
            --apollo-led-amber: #f7c04a;
            --apollo-led-red: #ff6b6b;
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            margin: 0;
            background: linear-gradient(180deg, #1a1d21 0%, #14171a 100%);
            color: var(--lcars-ink);
            font-family: "Rajdhani", "Helvetica Neue", Arial, sans-serif;
            overflow: auto;
        }

        .synth-container {
            width: 100%;
            max-width: 1920px;
            margin: 0 auto;
            padding: 8px 12px 16px;
            display: flex;
        }

        .synth-card {
            flex: 1;
            background: linear-gradient(180deg, #2b3036 0%, #20242a 100%);
            border-radius: 12px;
            padding: 8px 16px 12px 16px;
            position: relative;
            overflow: hidden;
            box-shadow: var(--lcars-shadow);
            border: 1px solid rgba(255, 255, 255, 0.08);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .synth-card::before {
            content: none;
        }

        .synth-card::after {
            content: none;
        }


        .synth-header {
            display: grid;
            grid-template-columns: minmax(260px, 0.9fr) minmax(660px, 1.4fr);
            gap: 6px 16px;
            align-items: start;
        }

        .header-title {
            max-width: 520px;
        }

        .header-right {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: flex-end;
            justify-self: end;
            width: 100%;
        }

        .quick-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
        }

        .quick-left {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .quick-right {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: flex-end;
            align-items: center;
        }

        .quick-bar .header-actions {
            margin-top: 0;
        }

        .title-eyebrow {
            font-size: 10px;
            letter-spacing: 0.28em;
            text-transform: uppercase;
            color: var(--lcars-muted);
        }

        .synth-title {
            font-size: 26px;
            font-weight: 700;
            text-transform: uppercase;
            margin: 4px 0 4px;
            font-family: "Orbitron", "Rajdhani", sans-serif;
        }

        .synth-subtitle {
            margin: 0;
            color: var(--lcars-muted);
            max-width: 460px;
            font-size: 13px;
            line-height: 1.35;
        }

        .header-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            margin-top: 0;
            justify-content: flex-end;
        }

        .synth-button {
            padding: 6px 14px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.15);
            min-height: 30px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 10px;
            font-family: "Orbitron", "Rajdhani", sans-serif;
            background: linear-gradient(180deg, #3a4048 0%, #2a2f35 100%);
            color: #e3e8ee;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12), inset 0 -2px 6px rgba(0, 0, 0, 0.55);
        }

        .synth-button:active {
            transform: translateY(1px) scale(0.99);
        }

        .synth-button:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            box-shadow: none;
        }

        .synth-button-primary {
            background: linear-gradient(180deg, #2f7d57 0%, #1f5a3e 100%);
            color: #eafbf2;
            border-color: rgba(89, 240, 161, 0.45);
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -2px 6px rgba(0, 0, 0, 0.6),
                0 0 10px rgba(89, 240, 161, 0.25);
        }

        .synth-button-secondary {
            background: linear-gradient(180deg, #4a515a 0%, #30353c 100%);
            color: #e6eaef;
            border-color: rgba(255, 255, 255, 0.2);
        }

        .synth-button-outline {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--lcars-ink);
        }

        .status-row {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
            margin: 0;
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            padding: 3px 8px;
            border-radius: 8px;
            background: #2a2f35;
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: var(--lcars-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .visualizer-card {
            background: #262b31;
            border-radius: 10px;
            padding: 8px 10px;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        .visualizer-card.compact {
            padding: 6px 8px;
            width: 100%;
            align-self: flex-start;
        }

        .visualizer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 6px;
        }

        .visualizer-title {
            display: flex;
            align-items: baseline;
            gap: 12px;
        }

        .visualizer {
            width: 100%;
            height: 96px;
            background: rgba(10, 12, 14, 0.9);
            border-radius: 12px;
            overflow: hidden;
        }

        .scope-row {
            display: grid;
            grid-template-columns: 64px minmax(286px, 1.3fr) minmax(286px, 1.3fr);
            gap: 6px;
            width: 100%;
            align-items: stretch;
        }

        .vu-card {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .vu-meter {
            width: 100%;
            height: 96px;
            background: rgba(6, 10, 24, 0.95);
            border-radius: 12px;
            overflow: hidden;
        }

        .controls-stack {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .controls-grid {
            min-height: 0;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            grid-auto-rows: auto;
            gap: 10px 12px;
        }

        .controls-grid.matrix {
            grid-template-columns: repeat(4, minmax(0, 1fr));
        }

        .control-section {
            background: #2a2f35;
            border-radius: 10px;
            padding: 8px 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 0;
        }

        .step-grid {
            display: grid;
            grid-template-columns: repeat(8, minmax(0, 1fr));
            gap: 4px;
        }

        .step-button {
            background: #1f2328;
            color: var(--lcars-muted);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            padding: 4px 3px;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .step-button.active {
            background: linear-gradient(180deg, #2f7d57 0%, #1f5a3e 100%);
            color: #eafbf2;
            border-color: transparent;
        }

        .step-button.off {
            opacity: 0.6;
        }

        .synth-container[data-performance="true"] .control-section.presets,
        .synth-container[data-performance="true"] .control-section.keyboard,
        .synth-container[data-performance="true"] .control-section.sequencer,
        .synth-container[data-performance="true"] .help-panel {
            display: none;
        }

        .control-section.accent-orange { border-color: rgba(255, 255, 255, 0.12); }
        .control-section.accent-lilac { border-color: rgba(255, 255, 255, 0.12); }
        .control-section.accent-blue { border-color: rgba(255, 255, 255, 0.12); }
        .control-section.accent-teal { border-color: rgba(255, 255, 255, 0.12); }
        .control-section.accent-peach { border-color: rgba(255, 255, 255, 0.12); }
        .control-section.accent-yellow { border-color: rgba(255, 255, 255, 0.12); }

        .control-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            margin: 0;
        }

        .control-container {
            margin-bottom: 2px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .knob-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 6px 8px;
            margin-top: 2px;
        }

        .knob-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 1px 0;
            text-align: center;
        }

        .knob-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
        }

        .knob-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
        }

        .knob-shell {
            --knob-size: 46px;
            --knob-value: 0;
            --knob-start: 240deg;
            --knob-sweep: 240deg;
            position: relative;
            width: var(--knob-size);
            height: var(--knob-size);
            flex: 0 0 auto;
        }

        .knob-input {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
            z-index: 2;
        }

        .knob-ring {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #1b1b1b 0%, #0c0c0c 40%, #050505 100%);
            border: 2px solid rgba(255, 255, 255, 0.08);
            box-shadow: inset 0 6px 14px rgba(0, 0, 0, 0.75), 0 10px 18px rgba(0, 0, 0, 0.45);
        }

        .knob-ring::before {
            content: "";
            position: absolute;
            inset: 5px;
            border-radius: 50%;
            background: repeating-conic-gradient(
                from var(--knob-start),
                rgba(255, 255, 255, 0.15) 0deg 6deg,
                rgba(0, 0, 0, 0) 6deg 12deg
            );
            opacity: 0.5;
        }

        .knob-ring::after {
            content: "";
            position: absolute;
            inset: 5px;
            border-radius: 50%;
            background: repeating-conic-gradient(
                from var(--knob-start),
                rgba(140, 255, 78, 0.95) 0deg 6deg,
                rgba(0, 0, 0, 0) 6deg 12deg
            );
            filter: drop-shadow(0 0 6px rgba(140, 255, 78, 0.6));
            mask: conic-gradient(
                from var(--knob-start),
                #000 0deg,
                #000 calc(var(--knob-sweep) * var(--knob-value)),
                transparent 0deg
            );
            -webkit-mask: conic-gradient(
                from var(--knob-start),
                #000 0deg,
                #000 calc(var(--knob-sweep) * var(--knob-value)),
                transparent 0deg
            );
        }

        .knob-core {
            position: absolute;
            inset: 10px;
            border-radius: 50%;
            background:
                radial-gradient(circle at 30% 30%, #f0f0f0, #c9c9c9 58%, #a1a1a1 100%),
                repeating-conic-gradient(
                    from 0deg,
                    rgba(255, 255, 255, 0.2) 0deg 6deg,
                    rgba(0, 0, 0, 0.2) 6deg 12deg
                );
            background-blend-mode: overlay;
            box-shadow:
                inset 0 2px 6px rgba(255, 255, 255, 0.6),
                inset 0 -6px 10px rgba(0, 0, 0, 0.4),
                0 3px 8px rgba(0, 0, 0, 0.4);
        }

        .knob-core::after {
            content: "";
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #8f8f8f;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .knob-input:focus-visible ~ .knob-ring {
            outline: 2px solid var(--lcars-blue);
            outline-offset: 4px;
        }

        .knob-shell.is-disabled {
            opacity: 0.5;
        }

        .knob-shell.is-disabled .knob-ring::after {
            filter: none;
            opacity: 0.4;
        }

        @media (max-width: 1200px) {
            .knob-grid {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
        }

        @media (max-width: 900px) {
            .knob-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        @media (max-width: 600px) {
            .knob-grid {
                grid-template-columns: repeat(1, minmax(0, 1fr));
            }
        }

        .synth-slider {
            width: 100%;
            height: 9px;
            -webkit-appearance: none;
            background: rgba(226, 232, 240, 0.18);
            border-radius: 999px;
            outline: none;
            margin: 6px 0 2px;
        }

        .synth-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: var(--lcars-orange);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 6px 14px rgba(249, 168, 38, 0.3);
            border: 2px solid #05070d;
        }

        .synth-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: var(--lcars-orange);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #05070d;
        }

        .synth-slider:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .frequency-markers {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--lcars-muted);
            padding: 0 2px;
        }

        .pill-group {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .pill {
            border-radius: 999px 8px 8px 999px;
            padding: 4px 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: #252a30;
            color: var(--lcars-muted);
            cursor: pointer;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
        }

        .pill.active {
            background: linear-gradient(180deg, #2f7d57 0%, #1f5a3e 100%);
            color: #eafbf2;
            border-color: transparent;
        }

        .pill:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .input {
            width: 100%;
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: #1f2328;
            color: var(--lcars-ink);
            font-size: 12px;
            font-family: "Rajdhani", "Helvetica Neue", Arial, sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .preset-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }

        .mono {
            font-family: "IBM Plex Mono", "SFMono-Regular", ui-monospace, monospace;
            font-size: 10px;
            color: var(--lcars-muted);
        }

        .help-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 6px 8px;
            border: 1px dashed rgba(255, 255, 255, 0.15);
            font-size: 11px;
            color: var(--lcars-muted);
        }

        .help-panel summary {
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
        }

        .help-panel p {
            margin: 4px 0;
        }

        @media (max-width: 1100px) {
            body {
                overflow: auto;
            }

            .synth-header {
                grid-template-columns: 1fr;
            }

            .header-actions {
                justify-self: start;
                justify-content: flex-start;
            }

            .visualizer-card.compact {
                width: 100%;
            }

            .controls-grid,
            .controls-grid.matrix {
                grid-template-columns: 1fr;
                grid-template-rows: none;
            }
        }

        @media (max-width: 900px) {
            .synth-container {
                padding: 8px;
            }

            .synth-card {
                padding: 12px 12px 14px 24px;
            }

            .controls-grid,
            .controls-grid.matrix {
                grid-template-columns: 1fr;
                grid-template-rows: none;
            }

            .visualizer {
                height: 110px;
            }
        }
    </style>
</head>
<body>
    <div id="synth-root"></div>
    <script type="text/babel">
        const MIN_FREQ = 20;
        const MAX_FREQ = 20000;
        const MIN_CUTOFF = 60;
        const MAX_CUTOFF = 16000;

        const WAVEFORMS = ["sine", "triangle", "sawtooth", "square"];
        const FILTER_TYPES = ["lowpass", "highpass", "bandpass"];
        const ARP_PATTERNS = ["up", "down", "random"];
        const VOICE_MODES = ["mono", "poly"];
        const LFO_TARGETS = ["pitch", "filter", "amp"];
        const MOD_TARGETS = ["pitch", "filter", "amp", "lfo"];
        const SEQ_OFFSETS = [null, 0, 5, 7, 12, -5, -7, -12];
        const DEFAULT_VISUALIZER = "waveform";
        const STORAGE_KEY = "simpleSynthPresets";
        const MAX_EXPORT_DURATION = 30;

        const DEFAULT_SEQ_STEPS = [0, null, 7, null, 12, null, 7, null, 0, null, -5, null, -7, null, 5, null];

        const DEFAULT_PARAMS = {
            frequency: 440,
            volume: 0.5,
            reverb: 0.25,
            complexity: 0.4,
            waveform: "sine",
            attack: 0.02,
            decay: 0.18,
            sustain: 0.7,
            release: 0.35,
            filterType: "lowpass",
            filterCutoff: 12000,
            filterResonance: 0.8,
            filterEnvAmount: 0.3,
            voiceMode: "mono",
            detune: 0,
            unisonCount: 1,
            unisonSpread: 8,
            subLevel: 0.2,
            noiseLevel: 0.05,
            glide: 0.05,
            lfoEnabled: false,
            lfoRate: 3.5,
            lfoDepth: 0.2,
            lfoWaveform: "sine",
            lfoTarget: "filter",
            modWheel: 0,
            modWheelTarget: "lfo",
            velocityAmount: 0.5,
            drive: 0.2,
            chorusRate: 0.8,
            chorusDepth: 0.35,
            chorusMix: 0.2,
            delayTime: 0.25,
            delayFeedback: 0.35,
            delayMix: 0.15,
            bitDepth: 12,
            bitReduce: 1,
            bitMix: 0.0,
            stereoWidth: 0.25,
            arpEnabled: false,
            arpRate: 120,
            arpPattern: "up",
            seqEnabled: false,
            seqLength: 16,
            seqRate: 120,
            seqGate: 0.6,
            seqSwing: 0.1,
            seqHold: false,
            seqProbability: 1,
            seqSteps: DEFAULT_SEQ_STEPS.slice(),
            midiEnabled: false,
            performanceMode: false
        };

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        const toNumber = (value, fallback, min, max) => {
            const parsed = parseFloat(value);
            if (!Number.isFinite(parsed)) return fallback;
            if (min === undefined || max === undefined) return parsed;
            return clamp(parsed, min, max);
        };

        const toInt = (value, fallback, min, max) => {
            const parsed = parseInt(value, 10);
            if (!Number.isFinite(parsed)) return fallback;
            if (min === undefined || max === undefined) return parsed;
            return clamp(parsed, min, max);
        };

        const freqToSlider = (freq) => Math.log2(freq / MIN_FREQ) / Math.log2(MAX_FREQ / MIN_FREQ);
        const sliderToFreq = (value) => MIN_FREQ * Math.pow(MAX_FREQ / MIN_FREQ, value);
        const cutoffToSlider = (freq) => Math.log2(freq / MIN_CUTOFF) / Math.log2(MAX_CUTOFF / MIN_CUTOFF);
        const sliderToCutoff = (value) => MIN_CUTOFF * Math.pow(MAX_CUTOFF / MIN_CUTOFF, value);

        const formatFrequency = (freq) => (
            freq >= 1000 ? `${(freq / 1000).toFixed(2)} kHz` : `${Math.round(freq)} Hz`
        );
        const formatSeconds = (value) => `${value.toFixed(2)}s`;
        const formatPercentage = (value) => `${Math.round(value * 100)}%`;

        const getHarmonicsCount = (complexity) => Math.floor(clamp(complexity, 0, 1) * 8) + 1;
        const getKnobPercent = (value, min, max) => {
            if (max === min) return 0;
            const numeric = Number(value);
            return clamp((numeric - min) / (max - min), 0, 1);
        };

        const KnobControl = ({ label, valueLabel, value, min, max, step, onChange, disabled = false }) => {
            const percent = getKnobPercent(value, min, max);

            return (
                <div className="knob-control">
                    <div
                        className={`knob-shell${disabled ? " is-disabled" : ""}`}
                        style={{ "--knob-value": percent }}
                    >
                        <input
                            type="range"
                            className="knob-input"
                            aria-label={label}
                            value={value}
                            min={min}
                            max={max}
                            step={step}
                            onChange={onChange}
                            disabled={disabled}
                        />
                        <div className="knob-ring" aria-hidden="true"></div>
                        <div className="knob-core" aria-hidden="true"></div>
                    </div>
                    <div className="knob-text">
                        <span className="knob-label">{label}</span>
                        {valueLabel !== undefined && valueLabel !== null && (
                            <span className="mono">{valueLabel}</span>
                        )}
                    </div>
                </div>
            );
        };

        const encodeWav = (audioBuffer) => {
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const length = audioBuffer.length * numChannels * 2;
            const buffer = new ArrayBuffer(44 + length);
            const view = new DataView(buffer);
            let offset = 0;

            const writeString = (value) => {
                for (let i = 0; i < value.length; i++) {
                    view.setUint8(offset + i, value.charCodeAt(i));
                }
                offset += value.length;
            };

            writeString("RIFF");
            view.setUint32(offset, 36 + length, true);
            offset += 4;
            writeString("WAVE");
            writeString("fmt ");
            view.setUint32(offset, 16, true);
            offset += 4;
            view.setUint16(offset, 1, true);
            offset += 2;
            view.setUint16(offset, numChannels, true);
            offset += 2;
            view.setUint32(offset, sampleRate, true);
            offset += 4;
            view.setUint32(offset, sampleRate * numChannels * 2, true);
            offset += 4;
            view.setUint16(offset, numChannels * 2, true);
            offset += 2;
            view.setUint16(offset, 16, true);
            offset += 2;
            writeString("data");
            view.setUint32(offset, length, true);
            offset += 4;

            const channelData = [];
            for (let channel = 0; channel < numChannels; channel++) {
                channelData.push(audioBuffer.getChannelData(channel));
            }

            for (let i = 0; i < audioBuffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = clamp(channelData[channel][i], -1, 1);
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
                    offset += 2;
                }
            }

            return new Blob([buffer], { type: "audio/wav" });
        };

        const createImpulseResponseForContext = (ctx, duration) => {
            const length = Math.floor(ctx.sampleRate * duration);
            const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
            const leftChannel = impulse.getChannelData(0);
            const rightChannel = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                const decay = Math.exp(-i / (ctx.sampleRate * 0.1));
                const noise = Math.random() * 2 - 1;
                leftChannel[i] = noise * decay;
                rightChannel[i] = noise * decay;
            }

            return impulse;
        };

        const createNoiseBufferForContext = (ctx, duration = 2) => {
            const bufferSize = Math.floor(ctx.sampleRate * duration);
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            return buffer;
        };

        const triggerDownload = (blob, filename) => {
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            const canDownload = typeof link.download === "string";

            if (canDownload) {
                link.href = url;
                link.download = filename;
                link.style.display = "none";
                document.body.appendChild(link);
                link.click();
                link.remove();
            } else {
                window.location.href = url;
            }

            setTimeout(() => URL.revokeObjectURL(url), 1000);
        };

        const encodeSeqSteps = (steps) => steps.map((step) => (step === null ? "x" : step)).join(".");
        const decodeSeqSteps = (value) => {
            if (!value) return DEFAULT_SEQ_STEPS.slice();
            const parts = value.split(".");
            const steps = parts.map((part) => (part === "x" ? null : parseInt(part, 10)));
            while (steps.length < 16) steps.push(null);
            return steps.slice(0, 16);
        };

        const encodeStateToQuery = (params, visualizerMode, presetFilter) => {
            const query = new URLSearchParams();
            query.set("f", params.frequency.toFixed(2));
            query.set("v", params.volume.toFixed(2));
            query.set("rv", params.reverb.toFixed(2));
            query.set("c", params.complexity.toFixed(3));
            query.set("wf", params.waveform);
            query.set("a", params.attack.toFixed(3));
            query.set("d", params.decay.toFixed(3));
            query.set("s", params.sustain.toFixed(3));
            query.set("rl", params.release.toFixed(3));
            query.set("ft", params.filterType);
            query.set("fc", params.filterCutoff.toFixed(1));
            query.set("fq", params.filterResonance.toFixed(2));
            query.set("fe", params.filterEnvAmount.toFixed(2));
            query.set("vo", params.voiceMode);
            query.set("dt", params.detune.toFixed(1));
            query.set("un", params.unisonCount);
            query.set("us", params.unisonSpread.toFixed(1));
            query.set("sub", params.subLevel.toFixed(2));
            query.set("nz", params.noiseLevel.toFixed(2));
            query.set("gl", params.glide.toFixed(2));
            query.set("lfo", params.lfoEnabled ? "1" : "0");
            query.set("lr", params.lfoRate.toFixed(2));
            query.set("ld", params.lfoDepth.toFixed(2));
            query.set("lw", params.lfoWaveform);
            query.set("lt", params.lfoTarget);
            query.set("mw", params.modWheel.toFixed(2));
            query.set("mt", params.modWheelTarget);
            query.set("va", params.velocityAmount.toFixed(2));
            query.set("dr", params.drive.toFixed(2));
            query.set("cr", params.chorusRate.toFixed(2));
            query.set("cd", params.chorusDepth.toFixed(2));
            query.set("cm", params.chorusMix.toFixed(2));
            query.set("dtm", params.delayTime.toFixed(2));
            query.set("df", params.delayFeedback.toFixed(2));
            query.set("dm", params.delayMix.toFixed(2));
            query.set("bd", params.bitDepth);
            query.set("br", params.bitReduce);
            query.set("bm", params.bitMix.toFixed(2));
            query.set("sw", params.stereoWidth.toFixed(2));
            query.set("arp", params.arpEnabled ? "1" : "0");
            query.set("bpm", Math.round(params.arpRate));
            query.set("ap", params.arpPattern);
            query.set("seq", params.seqEnabled ? "1" : "0");
            query.set("sql", params.seqLength);
            query.set("sqr", Math.round(params.seqRate));
            query.set("sqg", params.seqGate.toFixed(2));
            query.set("sqs", params.seqSwing.toFixed(2));
            query.set("sqh", params.seqHold ? "1" : "0");
            query.set("sqp", params.seqProbability.toFixed(2));
            query.set("sqd", encodeSeqSteps(params.seqSteps));
            query.set("pm", params.performanceMode ? "1" : "0");
            query.set("vm", visualizerMode);
            if (presetFilter) query.set("pf", presetFilter);
            return query.toString();
        };

        const getInitialState = () => {
            const params = new URLSearchParams(window.location.search);
            const waveform = params.get("wf");
            const filterType = params.get("ft");
            const arpPattern = params.get("ap");
            const visualizerMode = params.get("vm");
            const voiceMode = params.get("vo");
            const lfoTarget = params.get("lt");
            const modTarget = params.get("mt");
            const lfoWave = params.get("lw");

            return {
                params: {
                    frequency: toNumber(params.get("f"), DEFAULT_PARAMS.frequency, MIN_FREQ, MAX_FREQ),
                    volume: toNumber(params.get("v"), DEFAULT_PARAMS.volume, 0, 1),
                    reverb: toNumber(params.get("rv"), DEFAULT_PARAMS.reverb, 0, 1),
                    complexity: toNumber(params.get("c"), DEFAULT_PARAMS.complexity, 0, 1),
                    waveform: WAVEFORMS.includes(waveform) ? waveform : DEFAULT_PARAMS.waveform,
                    attack: toNumber(params.get("a"), DEFAULT_PARAMS.attack, 0.005, 2),
                    decay: toNumber(params.get("d"), DEFAULT_PARAMS.decay, 0.02, 3),
                    sustain: toNumber(params.get("s"), DEFAULT_PARAMS.sustain, 0, 1),
                    release: toNumber(params.get("rl"), DEFAULT_PARAMS.release, 0.02, 3),
                    filterType: FILTER_TYPES.includes(filterType) ? filterType : DEFAULT_PARAMS.filterType,
                    filterCutoff: toNumber(params.get("fc"), DEFAULT_PARAMS.filterCutoff, MIN_CUTOFF, MAX_CUTOFF),
                    filterResonance: toNumber(params.get("fq"), DEFAULT_PARAMS.filterResonance, 0.1, 18),
                    filterEnvAmount: toNumber(params.get("fe"), DEFAULT_PARAMS.filterEnvAmount, 0, 1.5),
                    voiceMode: VOICE_MODES.includes(voiceMode) ? voiceMode : DEFAULT_PARAMS.voiceMode,
                    detune: toNumber(params.get("dt"), DEFAULT_PARAMS.detune, -50, 50),
                    unisonCount: toInt(params.get("un"), DEFAULT_PARAMS.unisonCount, 1, 5),
                    unisonSpread: toNumber(params.get("us"), DEFAULT_PARAMS.unisonSpread, 0, 40),
                    subLevel: toNumber(params.get("sub"), DEFAULT_PARAMS.subLevel, 0, 0.8),
                    noiseLevel: toNumber(params.get("nz"), DEFAULT_PARAMS.noiseLevel, 0, 0.5),
                    glide: toNumber(params.get("gl"), DEFAULT_PARAMS.glide, 0, 1.5),
                    lfoEnabled: params.get("lfo") === "1",
                    lfoRate: toNumber(params.get("lr"), DEFAULT_PARAMS.lfoRate, 0.1, 20),
                    lfoDepth: toNumber(params.get("ld"), DEFAULT_PARAMS.lfoDepth, 0, 1),
                    lfoWaveform: WAVEFORMS.includes(lfoWave) ? lfoWave : DEFAULT_PARAMS.lfoWaveform,
                    lfoTarget: LFO_TARGETS.includes(lfoTarget) ? lfoTarget : DEFAULT_PARAMS.lfoTarget,
                    modWheel: toNumber(params.get("mw"), DEFAULT_PARAMS.modWheel, 0, 1),
                    modWheelTarget: MOD_TARGETS.includes(modTarget) ? modTarget : DEFAULT_PARAMS.modWheelTarget,
                    velocityAmount: toNumber(params.get("va"), DEFAULT_PARAMS.velocityAmount, 0, 1),
                    drive: toNumber(params.get("dr"), DEFAULT_PARAMS.drive, 0, 1),
                    chorusRate: toNumber(params.get("cr"), DEFAULT_PARAMS.chorusRate, 0.1, 6),
                    chorusDepth: toNumber(params.get("cd"), DEFAULT_PARAMS.chorusDepth, 0, 1),
                    chorusMix: toNumber(params.get("cm"), DEFAULT_PARAMS.chorusMix, 0, 1),
                    delayTime: toNumber(params.get("dtm"), DEFAULT_PARAMS.delayTime, 0, 1),
                    delayFeedback: toNumber(params.get("df"), DEFAULT_PARAMS.delayFeedback, 0, 0.85),
                    delayMix: toNumber(params.get("dm"), DEFAULT_PARAMS.delayMix, 0, 1),
                    bitDepth: toInt(params.get("bd"), DEFAULT_PARAMS.bitDepth, 2, 16),
                    bitReduce: toInt(params.get("br"), DEFAULT_PARAMS.bitReduce, 1, 20),
                    bitMix: toNumber(params.get("bm"), DEFAULT_PARAMS.bitMix, 0, 1),
                    stereoWidth: toNumber(params.get("sw"), DEFAULT_PARAMS.stereoWidth, 0, 1),
                    arpEnabled: params.get("arp") === "1",
                    arpRate: toNumber(params.get("bpm"), DEFAULT_PARAMS.arpRate, 40, 220),
                    arpPattern: ARP_PATTERNS.includes(arpPattern) ? arpPattern : DEFAULT_PARAMS.arpPattern,
                    seqEnabled: params.get("seq") === "1",
                    seqLength: toInt(params.get("sql"), DEFAULT_PARAMS.seqLength, 8, 16),
                    seqRate: toNumber(params.get("sqr"), DEFAULT_PARAMS.seqRate, 40, 240),
                    seqGate: toNumber(params.get("sqg"), DEFAULT_PARAMS.seqGate, 0.1, 1),
                    seqSwing: toNumber(params.get("sqs"), DEFAULT_PARAMS.seqSwing, 0, 0.5),
                    seqHold: params.get("sqh") === "1",
                    seqProbability: toNumber(params.get("sqp"), DEFAULT_PARAMS.seqProbability, 0, 1),
                    seqSteps: decodeSeqSteps(params.get("sqd")),
                    midiEnabled: DEFAULT_PARAMS.midiEnabled,
                    performanceMode: params.get("pm") === "1"
                },
                visualizerMode: ["waveform", "spectrum"].includes(visualizerMode)
                    ? visualizerMode
                    : DEFAULT_VISUALIZER,
                presetFilter: params.get("pf") || ""
            };
        };

        const loadPresets = () => {
            try {
                const stored = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
                return Array.isArray(stored) ? stored : [];
            } catch (error) {
                return [];
            }
        };

        const savePresets = (presets) => {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(presets));
            } catch (error) {}
        };

        const SoundSynthesizer = () => {
            const initialState = React.useMemo(getInitialState, []);

            const [soundParams, setSoundParams] = React.useState(initialState.params);
            const [visualizerMode, setVisualizerMode] = React.useState(initialState.visualizerMode);
            const [presetFilter, setPresetFilter] = React.useState(initialState.presetFilter);
            const [isPlaying, setIsPlaying] = React.useState(false);
            const [displayFrequency, setDisplayFrequency] = React.useState(initialState.params.frequency);
            const [keyboardOctave, setKeyboardOctave] = React.useState(4);
            const [presetName, setPresetName] = React.useState("");
            const [presetTags, setPresetTags] = React.useState("");
            const [selectedPreset, setSelectedPreset] = React.useState("");
            const [presets, setPresets] = React.useState(() => loadPresets());
            const [statusMessage, setStatusMessage] = React.useState("");
            const [exportDuration, setExportDuration] = React.useState(10);
            const [isExporting, setIsExporting] = React.useState(false);

            const audioContextRef = React.useRef(null);
            const voiceBusGainRef = React.useRef(null);
            const driveNodeRef = React.useRef(null);
            const filterNodeRef = React.useRef(null);
            const bitCrusherRef = React.useRef(null);
            const bitCrusherMixRef = React.useRef({ dry: null, wet: null, input: null, output: null });
            const chorusRef = React.useRef({ input: null, delay: null, wet: null, dry: null, lfo: null, lfoGain: null, output: null });
            const delayRef = React.useRef({ input: null, delay: null, wet: null, dry: null, feedback: null, output: null });
            const limiterNodeRef = React.useRef(null);
            const masterGainRef = React.useRef(null);
            const reverbNodeRef = React.useRef(null);
            const dryGainRef = React.useRef(null);
            const wetGainRef = React.useRef(null);
            const mixBusRef = React.useRef(null);
            const widthRef = React.useRef({ splitter: null, delay: null, merger: null });
            const analyserNodeRef = React.useRef(null);
            const analyserBufferRef = React.useRef({ waveform: null, spectrum: null });
            const waveformCanvasRef = React.useRef(null);
            const spectrumCanvasRef = React.useRef(null);
            const vuCanvasRef = React.useRef(null);
            const animationRef = React.useRef(null);
            const lfoRef = React.useRef({ osc: null, gain: null });
            const lfoTargetRef = React.useRef("filter");
            const noiseBufferRef = React.useRef(null);
            const isInitializedRef = React.useRef(false);
            const activeFrequencyRef = React.useRef(initialState.params.frequency);
            const arpTimerRef = React.useRef(null);
            const arpStepRef = React.useRef(0);
            const arpOffsetRef = React.useRef(0);
            const seqTimerRef = React.useRef(null);
            const seqStepRef = React.useRef(0);
            const seqReleaseRef = React.useRef(null);
            const hasStartedRef = React.useRef(false);
            const keyboardOctaveRef = React.useRef(keyboardOctave);
            const soundParamsRef = React.useRef(soundParams);
            const isPlayingRef = React.useRef(isPlaying);
            const messageTimerRef = React.useRef(null);
            const urlSyncTimerRef = React.useRef(null);
            const urlSyncRef = React.useRef(false);
            const voicesRef = React.useRef(new Map());
            const rootVoiceIdRef = React.useRef("root");
            const activeKeyVoicesRef = React.useRef(new Map());
            const midiVoicesRef = React.useRef(new Map());
            const voiceIdRef = React.useRef(0);
            const midiAccessRef = React.useRef(null);
            const fileInputRef = React.useRef(null);

            React.useEffect(() => {
                keyboardOctaveRef.current = keyboardOctave;
            }, [keyboardOctave]);

            React.useEffect(() => {
                soundParamsRef.current = soundParams;
            }, [soundParams]);

            React.useEffect(() => {
                isPlayingRef.current = isPlaying;
            }, [isPlaying]);

            React.useEffect(() => {
                savePresets(presets);
            }, [presets]);

            React.useEffect(() => {
                if (!urlSyncRef.current) {
                    urlSyncRef.current = true;
                    return;
                }
                if (urlSyncTimerRef.current) {
                    clearTimeout(urlSyncTimerRef.current);
                }
                urlSyncTimerRef.current = setTimeout(() => {
                    const query = encodeStateToQuery(soundParams, visualizerMode, presetFilter);
                    if (window.location.search !== `?${query}`) {
                        window.history.replaceState({}, "", `${window.location.pathname}?${query}`);
                    }
                    urlSyncTimerRef.current = null;
                }, 300);

                return () => {
                    if (urlSyncTimerRef.current) {
                        clearTimeout(urlSyncTimerRef.current);
                        urlSyncTimerRef.current = null;
                    }
                };
            }, [soundParams, visualizerMode, presetFilter]);

            const flashMessage = (message) => {
                if (messageTimerRef.current) {
                    clearTimeout(messageTimerRef.current);
                }
                setStatusMessage(message);
                if (message) {
                    messageTimerRef.current = setTimeout(() => setStatusMessage(""), 2200);
                }
            };

            const hapticPulse = (duration = 8) => {
                if (navigator.vibrate) {
                    navigator.vibrate(duration);
                }
            };

            const generateVoiceId = (prefix) => {
                voiceIdRef.current += 1;
                return `${prefix}-${voiceIdRef.current}`;
            };

            const makeNoiseBuffer = () => {
                if (!audioContextRef.current) return null;
                const bufferSize = audioContextRef.current.sampleRate * 2;
                const buffer = audioContextRef.current.createBuffer(1, bufferSize, audioContextRef.current.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                return buffer;
            };

            const stopOscillatorSet = (oscillators) => {
                oscillators.forEach(({ osc, gainNode }) => {
                    try {
                        osc.stop();
                        osc.disconnect();
                        if (gainNode) {
                            gainNode.disconnect();
                        }
                    } catch (error) {}
                });
            };

            const connectLfoToOscillator = (osc) => {
                if (!lfoRef.current.gain) return;
                try {
                    lfoRef.current.gain.connect(osc.detune);
                } catch (error) {}
            };

            const disconnectLfoFromOscillator = (osc) => {
                if (!lfoRef.current.gain) return;
                try {
                    lfoRef.current.gain.disconnect(osc.detune);
                } catch (error) {}
            };

            const createOscillatorSet = (baseFreq, params, envelopeGain) => {
                const ctx = audioContextRef.current;
                const now = ctx.currentTime;
                const oscillators = [];
                const numHarmonics = getHarmonicsCount(params.complexity);
                const unisonCount = Math.max(1, params.unisonCount);
                const spread = params.unisonSpread;
                const detuneBase = params.detune + (params.modWheelTarget === "pitch" ? params.modWheel * 30 : 0);

                for (let i = 0; i < numHarmonics; i++) {
                    const harmonicIndex = i + 1;
                    const baseHarmonic = baseFreq * harmonicIndex;
                    for (let u = 0; u < unisonCount; u++) {
                        const osc = ctx.createOscillator();
                        osc.type = params.waveform;
                        const detuneOffset = unisonCount === 1
                            ? 0
                            : (u - (unisonCount - 1) / 2) * (spread * 2);
                        osc.detune.setValueAtTime(detuneBase + detuneOffset, now);
                        osc.frequency.setValueAtTime(baseHarmonic, now);

                let gainNode = null;
                if (i === 0) {
                    if (unisonCount > 1) {
                        gainNode = ctx.createGain();
                        gainNode.gain.setValueAtTime(1 / unisonCount, now);
                        osc.connect(gainNode);
                        gainNode.connect(envelopeGain);
                    } else {
                        osc.connect(envelopeGain);
                    }
                } else {
                    gainNode = ctx.createGain();
                    const amplitude = Math.pow(0.5, i) * (1 - params.complexity * 0.3) * (1 / unisonCount);
                    gainNode.gain.setValueAtTime(amplitude, now);
                    osc.connect(gainNode);
                    gainNode.connect(envelopeGain);
                }

                        if (params.lfoEnabled && params.lfoTarget === "pitch") {
                            connectLfoToOscillator(osc);
                        }

                        osc.start();
                        oscillators.push({ osc, gainNode, harmonicIndex, baseHarmonic, detuneOffset });
                    }
                }

                return oscillators;
            };

            const createVoice = (frequency, params, id, velocity = 1) => {
                const ctx = audioContextRef.current;
                const envelopeGain = ctx.createGain();
                envelopeGain.gain.setValueAtTime(0, ctx.currentTime);
                envelopeGain.connect(voiceBusGainRef.current);

                const oscillators = createOscillatorSet(frequency, params, envelopeGain);

                let subOsc = null;
                let subGain = null;
                if (params.subLevel > 0) {
                    subOsc = ctx.createOscillator();
                    subGain = ctx.createGain();
                    subOsc.type = "sine";
                    subOsc.frequency.setValueAtTime(frequency * 0.5, ctx.currentTime);
                    subGain.gain.setValueAtTime(params.subLevel, ctx.currentTime);
                    subOsc.connect(subGain);
                    subGain.connect(envelopeGain);
                    subOsc.start();
                }

                let noiseSource = null;
                let noiseGain = null;
                if (params.noiseLevel > 0) {
                    if (!noiseBufferRef.current) {
                        noiseBufferRef.current = makeNoiseBuffer();
                    }
                    noiseSource = ctx.createBufferSource();
                    noiseSource.buffer = noiseBufferRef.current;
                    noiseSource.loop = true;
                    noiseGain = ctx.createGain();
                    noiseGain.gain.setValueAtTime(params.noiseLevel, ctx.currentTime);
                    noiseSource.connect(noiseGain);
                    noiseGain.connect(envelopeGain);
                    noiseSource.start();
                }

                return {
                    id,
                    frequency,
                    velocity,
                    envelopeGain,
                    oscillators,
                    subOsc,
                    subGain,
                    noiseSource,
                    noiseGain,
                    cleanupTimer: null
                };
            };

            const destroyVoice = (id) => {
                const voice = voicesRef.current.get(id);
                if (!voice) return;
                if (voice.cleanupTimer) {
                    clearTimeout(voice.cleanupTimer);
                }
                stopOscillatorSet(voice.oscillators);
                if (voice.subOsc) {
                    try {
                        voice.subOsc.stop();
                        voice.subOsc.disconnect();
                        voice.subGain.disconnect();
                    } catch (error) {}
                }
                if (voice.noiseSource) {
                    try {
                        voice.noiseSource.stop();
                        voice.noiseSource.disconnect();
                        voice.noiseGain.disconnect();
                    } catch (error) {}
                }
                try {
                    voice.envelopeGain.disconnect();
                } catch (error) {}
                voicesRef.current.delete(id);
            };

            const triggerFilterEnvelope = (velocity = 1) => {
                if (!audioContextRef.current || !filterNodeRef.current) return;
                const params = soundParamsRef.current;
                const now = audioContextRef.current.currentTime;
                const baseCutoff = getEffectiveCutoff(params);
                const envAmount = params.filterEnvAmount;
                if (envAmount <= 0) {
                    filterNodeRef.current.frequency.setTargetAtTime(baseCutoff, now, 0.02);
                    return;
                }
                const velocityScale = 1 - params.velocityAmount + params.velocityAmount * velocity;
                const peak = baseCutoff * Math.pow(2, envAmount * 2 * velocityScale);
                const sustain = baseCutoff + (peak - baseCutoff) * params.sustain;
                const attackEnd = now + params.attack;
                const decayEnd = attackEnd + params.decay;

                filterNodeRef.current.frequency.cancelScheduledValues(now);
                filterNodeRef.current.frequency.setValueAtTime(baseCutoff, now);
                filterNodeRef.current.frequency.linearRampToValueAtTime(peak, attackEnd);
                filterNodeRef.current.frequency.linearRampToValueAtTime(sustain, decayEnd);
            };

            const releaseFilterEnvelope = () => {
                if (!audioContextRef.current || !filterNodeRef.current) return;
                const params = soundParamsRef.current;
                const now = audioContextRef.current.currentTime;
                filterNodeRef.current.frequency.cancelScheduledValues(now);
                filterNodeRef.current.frequency.setTargetAtTime(getEffectiveCutoff(params), now, params.release);
            };

            const triggerVoiceAttack = (voice, velocity = 1) => {
                if (!audioContextRef.current) return;
                const params = soundParamsRef.current;
                const now = audioContextRef.current.currentTime;
                const gain = voice.envelopeGain.gain;
                const velocityScale = 1 - params.velocityAmount + params.velocityAmount * velocity;
                const peak = clamp(velocityScale, 0, 1);

                gain.cancelScheduledValues(now);
                gain.setValueAtTime(gain.value, now);
                gain.linearRampToValueAtTime(peak, now + params.attack);
                gain.linearRampToValueAtTime(peak * params.sustain, now + params.attack + params.decay);
                triggerFilterEnvelope(velocity);
            };

            const triggerVoiceRelease = (voice) => {
                if (!audioContextRef.current) return;
                const { release } = soundParamsRef.current;
                const now = audioContextRef.current.currentTime;
                const gain = voice.envelopeGain.gain;

                gain.cancelScheduledValues(now);
                gain.setValueAtTime(gain.value, now);
                gain.linearRampToValueAtTime(0, now + release);
                releaseFilterEnvelope();

                const stopAt = now + release + 0.05;
                voice.oscillators.forEach(({ osc }) => {
                    try {
                        osc.stop(stopAt);
                    } catch (error) {}
                });

                if (voice.subOsc) {
                    try {
                        voice.subOsc.stop(stopAt);
                    } catch (error) {}
                }
                if (voice.noiseSource) {
                    try {
                        voice.noiseSource.stop(stopAt);
                    } catch (error) {}
                }

                if (voice.cleanupTimer) {
                    clearTimeout(voice.cleanupTimer);
                }
                voice.cleanupTimer = setTimeout(() => destroyVoice(voice.id), (release + 0.1) * 1000);
            };

            const rebuildVoiceOscillators = (voice, params) => {
                stopOscillatorSet(voice.oscillators);
                voice.oscillators = createOscillatorSet(voice.frequency, params, voice.envelopeGain);
                if (voice.subOsc && params.subLevel === 0) {
                    try {
                        voice.subOsc.stop();
                        voice.subOsc.disconnect();
                        voice.subGain.disconnect();
                    } catch (error) {}
                    voice.subOsc = null;
                }
                if (!voice.subOsc && params.subLevel > 0) {
                    const ctx = audioContextRef.current;
                    voice.subOsc = ctx.createOscillator();
                    voice.subGain = ctx.createGain();
                    voice.subOsc.type = "sine";
                    voice.subOsc.frequency.setValueAtTime(voice.frequency * 0.5, ctx.currentTime);
                    voice.subGain.gain.setValueAtTime(params.subLevel, ctx.currentTime);
                    voice.subOsc.connect(voice.subGain);
                    voice.subGain.connect(voice.envelopeGain);
                    voice.subOsc.start();
                } else if (voice.subGain) {
                    voice.subGain.gain.setTargetAtTime(params.subLevel, audioContextRef.current.currentTime, 0.05);
                }

                if (voice.noiseSource && params.noiseLevel === 0) {
                    try {
                        voice.noiseSource.stop();
                        voice.noiseSource.disconnect();
                        voice.noiseGain.disconnect();
                    } catch (error) {}
                    voice.noiseSource = null;
                }
                if (!voice.noiseSource && params.noiseLevel > 0) {
                    const ctx = audioContextRef.current;
                    if (!noiseBufferRef.current) {
                        noiseBufferRef.current = makeNoiseBuffer();
                    }
                    voice.noiseSource = ctx.createBufferSource();
                    voice.noiseSource.buffer = noiseBufferRef.current;
                    voice.noiseSource.loop = true;
                    voice.noiseGain = ctx.createGain();
                    voice.noiseGain.gain.setValueAtTime(params.noiseLevel, ctx.currentTime);
                    voice.noiseSource.connect(voice.noiseGain);
                    voice.noiseGain.connect(voice.envelopeGain);
                    voice.noiseSource.start();
                } else if (voice.noiseGain) {
                    voice.noiseGain.gain.setTargetAtTime(params.noiseLevel, audioContextRef.current.currentTime, 0.05);
                }
            };

            const updateVoiceWaveform = (voice, waveform) => {
                voice.oscillators.forEach(({ osc }) => {
                    osc.type = waveform;
                });
            };

            const updateVoiceDetune = (voice, params) => {
                const now = audioContextRef.current.currentTime;
                const baseDetune = params.detune + (params.modWheelTarget === "pitch" ? params.modWheel * 30 : 0);
                voice.oscillators.forEach(({ osc, detuneOffset }) => {
                    osc.detune.setTargetAtTime(baseDetune + detuneOffset, now, 0.02);
                });
            };

            const updateVoiceFrequency = (voice, frequency, params) => {
                if (!audioContextRef.current) return;
                const now = audioContextRef.current.currentTime;
                const glide = params.glide;
                voice.frequency = frequency;
                voice.oscillators.forEach(({ osc, harmonicIndex }) => {
                    const target = frequency * harmonicIndex;
                    if (glide > 0) {
                        osc.frequency.cancelScheduledValues(now);
                        osc.frequency.setValueAtTime(osc.frequency.value, now);
                        osc.frequency.linearRampToValueAtTime(target, now + glide);
                    } else {
                        osc.frequency.setValueAtTime(target, now);
                    }
                });
                if (voice.subOsc) {
                    if (glide > 0) {
                        voice.subOsc.frequency.cancelScheduledValues(now);
                        voice.subOsc.frequency.setValueAtTime(voice.subOsc.frequency.value, now);
                        voice.subOsc.frequency.linearRampToValueAtTime(frequency * 0.5, now + glide);
                    } else {
                        voice.subOsc.frequency.setValueAtTime(frequency * 0.5, now);
                    }
                }
            };

            const ensureRootVoice = (params) => {
                const id = rootVoiceIdRef.current;
                let voice = voicesRef.current.get(id);
                if (!voice) {
                    voice = createVoice(params.frequency, params, id, 1);
                    voicesRef.current.set(id, voice);
                }
                return voice;
            };

            const releaseExtraVoices = () => {
                voicesRef.current.forEach((voice, id) => {
                    if (id !== rootVoiceIdRef.current) {
                        triggerVoiceRelease(voice);
                    }
                });
                activeKeyVoicesRef.current.clear();
            };

            const releaseAllVoices = () => {
                voicesRef.current.forEach((voice) => {
                    triggerVoiceRelease(voice);
                });
                activeKeyVoicesRef.current.clear();
                midiVoicesRef.current.clear();
            };

            const makeDriveCurve = (amount) => {
                const k = amount * 100;
                const samples = 44100;
                const curve = new Float32Array(samples);
                const deg = Math.PI / 180;
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));
                }
                return curve;
            };

            const createImpulseResponse = (duration) => {
                if (!audioContextRef.current) return null;
                return createImpulseResponseForContext(audioContextRef.current, duration);
            };

            const setupBitCrusher = () => {
                if (!audioContextRef.current) return;
                const ctx = audioContextRef.current;
                const input = ctx.createGain();
                const output = ctx.createGain();
                const dry = ctx.createGain();
                const wet = ctx.createGain();
                const node = ctx.createScriptProcessor(4096, 1, 1);
                const settings = { bitDepth: soundParamsRef.current.bitDepth, bitReduce: soundParamsRef.current.bitReduce };
                let phaser = 0;
                let lastSample = 0;

                node.onaudioprocess = (event) => {
                    const inputBuffer = event.inputBuffer.getChannelData(0);
                    const outputBuffer = event.outputBuffer.getChannelData(0);
                    const step = Math.pow(0.5, settings.bitDepth);
                    const reduction = 1 / Math.max(1, settings.bitReduce);
                    for (let i = 0; i < inputBuffer.length; i++) {
                        phaser += reduction;
                        if (phaser >= 1.0) {
                            phaser -= 1.0;
                            lastSample = Math.round(inputBuffer[i] / step) * step;
                        }
                        outputBuffer[i] = lastSample;
                    }
                };

                input.connect(dry);
                input.connect(node);
                node.connect(wet);
                dry.connect(output);
                wet.connect(output);

                bitCrusherRef.current = node;
                bitCrusherMixRef.current = { input, output, dry, wet, settings };
            };

            const setupChorus = () => {
                const ctx = audioContextRef.current;
                const input = ctx.createGain();
                const output = ctx.createGain();
                const dry = ctx.createGain();
                const wet = ctx.createGain();
                const delay = ctx.createDelay(0.05);
                const lfo = ctx.createOscillator();
                const lfoGain = ctx.createGain();

                lfo.type = "sine";
                lfo.frequency.value = soundParamsRef.current.chorusRate;
                lfoGain.gain.value = soundParamsRef.current.chorusDepth * 0.015;
                delay.delayTime.value = 0.015;

                lfo.connect(lfoGain);
                lfoGain.connect(delay.delayTime);
                lfo.start();

                input.connect(dry);
                input.connect(delay);
                delay.connect(wet);
                dry.connect(output);
                wet.connect(output);

                chorusRef.current = { input, delay, dry, wet, lfo, lfoGain, output };
            };

            const setupDelay = () => {
                const ctx = audioContextRef.current;
                const input = ctx.createGain();
                const output = ctx.createGain();
                const dry = ctx.createGain();
                const wet = ctx.createGain();
                const delay = ctx.createDelay(1.2);
                const feedback = ctx.createGain();

                delay.delayTime.value = soundParamsRef.current.delayTime;
                feedback.gain.value = soundParamsRef.current.delayFeedback;

                input.connect(dry);
                input.connect(delay);
                delay.connect(feedback);
                feedback.connect(delay);
                delay.connect(wet);
                dry.connect(output);
                wet.connect(output);

                delayRef.current = { input, delay, dry, wet, feedback, output };
            };

            const setupWidth = () => {
                const ctx = audioContextRef.current;
                const splitter = ctx.createChannelSplitter(2);
                const merger = ctx.createChannelMerger(2);
                const delay = ctx.createDelay(0.05);

                widthRef.current = { splitter, delay, merger };
            };

            const initializeAudio = () => {
                if (isInitializedRef.current) return;
                audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();

                voiceBusGainRef.current = audioContextRef.current.createGain();
                driveNodeRef.current = audioContextRef.current.createWaveShaper();
                filterNodeRef.current = audioContextRef.current.createBiquadFilter();
                limiterNodeRef.current = audioContextRef.current.createDynamicsCompressor();
                masterGainRef.current = audioContextRef.current.createGain();
                reverbNodeRef.current = audioContextRef.current.createConvolver();
                dryGainRef.current = audioContextRef.current.createGain();
                wetGainRef.current = audioContextRef.current.createGain();
                mixBusRef.current = audioContextRef.current.createGain();
                analyserNodeRef.current = audioContextRef.current.createAnalyser();

                setupBitCrusher();
                setupChorus();
                setupDelay();
                setupWidth();

                lfoRef.current.osc = audioContextRef.current.createOscillator();
                lfoRef.current.gain = audioContextRef.current.createGain();
                lfoRef.current.osc.type = soundParamsRef.current.lfoWaveform;
                lfoRef.current.osc.frequency.setValueAtTime(soundParamsRef.current.lfoRate, audioContextRef.current.currentTime);
                lfoRef.current.gain.gain.setValueAtTime(0, audioContextRef.current.currentTime);
                lfoRef.current.osc.connect(lfoRef.current.gain);
                lfoRef.current.osc.start();

                voiceBusGainRef.current.gain.setValueAtTime(1, audioContextRef.current.currentTime);
                masterGainRef.current.gain.setValueAtTime(soundParamsRef.current.volume, audioContextRef.current.currentTime);

                driveNodeRef.current.curve = makeDriveCurve(soundParamsRef.current.drive);
                driveNodeRef.current.oversample = "4x";

                filterNodeRef.current.type = soundParamsRef.current.filterType;
                filterNodeRef.current.frequency.setValueAtTime(soundParamsRef.current.filterCutoff, audioContextRef.current.currentTime);
                filterNodeRef.current.Q.setValueAtTime(soundParamsRef.current.filterResonance, audioContextRef.current.currentTime);

                limiterNodeRef.current.threshold.setValueAtTime(-6, audioContextRef.current.currentTime);
                limiterNodeRef.current.knee.setValueAtTime(0, audioContextRef.current.currentTime);
                limiterNodeRef.current.ratio.setValueAtTime(12, audioContextRef.current.currentTime);
                limiterNodeRef.current.attack.setValueAtTime(0.003, audioContextRef.current.currentTime);
                limiterNodeRef.current.release.setValueAtTime(0.25, audioContextRef.current.currentTime);

                reverbNodeRef.current.buffer = createImpulseResponse(2.2);
                dryGainRef.current.gain.setValueAtTime(1 - soundParamsRef.current.reverb, audioContextRef.current.currentTime);
                wetGainRef.current.gain.setValueAtTime(soundParamsRef.current.reverb, audioContextRef.current.currentTime);

                analyserNodeRef.current.fftSize = 2048;
                analyserNodeRef.current.smoothingTimeConstant = 0.85;

                voiceBusGainRef.current.connect(driveNodeRef.current);
                driveNodeRef.current.connect(filterNodeRef.current);
                filterNodeRef.current.connect(bitCrusherMixRef.current.input);
                bitCrusherMixRef.current.output.connect(chorusRef.current.input);
                chorusRef.current.output.connect(delayRef.current.input);
                delayRef.current.output.connect(limiterNodeRef.current);
                limiterNodeRef.current.connect(masterGainRef.current);

                masterGainRef.current.connect(dryGainRef.current);
                masterGainRef.current.connect(reverbNodeRef.current);
                reverbNodeRef.current.connect(wetGainRef.current);
                dryGainRef.current.connect(mixBusRef.current);
                wetGainRef.current.connect(mixBusRef.current);

                mixBusRef.current.connect(widthRef.current.splitter);
                widthRef.current.splitter.connect(widthRef.current.merger, 0, 0);
                widthRef.current.splitter.connect(widthRef.current.delay, 1);
                widthRef.current.delay.connect(widthRef.current.merger, 0, 1);
                widthRef.current.merger.connect(analyserNodeRef.current);
                analyserNodeRef.current.connect(audioContextRef.current.destination);

                isInitializedRef.current = true;
                updateLfoTarget(soundParamsRef.current.lfoTarget, true);
                applyEffectMixes(soundParamsRef.current);
            };

            const applyEffectMixes = (params) => {
                if (!bitCrusherMixRef.current.dry) return;
                bitCrusherMixRef.current.dry.gain.setTargetAtTime(1 - params.bitMix, audioContextRef.current.currentTime, 0.02);
                bitCrusherMixRef.current.wet.gain.setTargetAtTime(params.bitMix, audioContextRef.current.currentTime, 0.02);

                chorusRef.current.dry.gain.setTargetAtTime(1 - params.chorusMix, audioContextRef.current.currentTime, 0.02);
                chorusRef.current.wet.gain.setTargetAtTime(params.chorusMix, audioContextRef.current.currentTime, 0.02);

                delayRef.current.dry.gain.setTargetAtTime(1 - params.delayMix, audioContextRef.current.currentTime, 0.02);
                delayRef.current.wet.gain.setTargetAtTime(params.delayMix, audioContextRef.current.currentTime, 0.02);
            };

            const getEffectiveCutoff = (params) => {
                const modBoost = params.modWheelTarget === "filter" ? params.modWheel * 4000 : 0;
                return clamp(params.filterCutoff + modBoost, MIN_CUTOFF, MAX_CUTOFF);
            };

            const updateLfoDepth = (params) => {
                if (!lfoRef.current.gain) return;
                if (!params.lfoEnabled) {
                    lfoRef.current.gain.gain.setTargetAtTime(0, audioContextRef.current.currentTime, 0.05);
                    return;
                }
                const wheelBoost = params.modWheelTarget === "lfo" ? 1 + params.modWheel : 1;
                let depth = params.lfoDepth * wheelBoost;
                let gainValue = 0;
                if (params.lfoTarget === "pitch") {
                    gainValue = depth * 40;
                } else if (params.lfoTarget === "filter") {
                    gainValue = depth * 2000;
                } else {
                    gainValue = depth * 0.5;
                }
                lfoRef.current.gain.gain.setTargetAtTime(gainValue, audioContextRef.current.currentTime, 0.05);
            };

            const updateLfoTarget = (target, force = false) => {
                if (!lfoRef.current.gain || !audioContextRef.current) return;
                if (!force && target === lfoTargetRef.current) return;
                try {
                    lfoRef.current.gain.disconnect();
                } catch (error) {}
                lfoTargetRef.current = target;
                if (target === "filter") {
                    lfoRef.current.gain.connect(filterNodeRef.current.frequency);
                } else if (target === "amp") {
                    lfoRef.current.gain.connect(masterGainRef.current.gain);
                } else {
                    voicesRef.current.forEach((voice) => {
                        voice.oscillators.forEach(({ osc }) => connectLfoToOscillator(osc));
                    });
                }
            };

            const updateRootFrequency = (rootFrequency, params = soundParamsRef.current) => {
                const offset = params.arpEnabled ? arpOffsetRef.current : 0;
                const freq = rootFrequency * Math.pow(2, offset / 12);
                activeFrequencyRef.current = freq;
                setDisplayFrequency(freq);
                const rootVoice = voicesRef.current.get(rootVoiceIdRef.current);
                if (rootVoice) {
                    updateVoiceFrequency(rootVoice, freq, params);
                }
            };

            const applyParamToAudio = React.useCallback((param, value, nextParams) => {
                if (!audioContextRef.current) return;
                const now = audioContextRef.current.currentTime;
                const params = nextParams || soundParamsRef.current;

                switch (param) {
                    case "frequency":
                        updateRootFrequency(value, params);
                        break;
                    case "volume": {
                        const modBoost = params.modWheelTarget === "amp" ? params.modWheel * 0.5 : 0;
                        masterGainRef.current.gain.setTargetAtTime(clamp(value + modBoost, 0, 1.2), now, 0.02);
                        break;
                    }
                    case "reverb":
                        dryGainRef.current.gain.setTargetAtTime(1 - value, now, 0.05);
                        wetGainRef.current.gain.setTargetAtTime(value, now, 0.05);
                        break;
                    case "complexity":
                    case "unisonCount":
                    case "unisonSpread":
                    case "subLevel":
                    case "noiseLevel":
                        voicesRef.current.forEach((voice) => rebuildVoiceOscillators(voice, params));
                        break;
                    case "waveform":
                        voicesRef.current.forEach((voice) => updateVoiceWaveform(voice, value));
                        break;
            case "detune":
            case "modWheel":
                voicesRef.current.forEach((voice) => updateVoiceDetune(voice, params));
                if (params.modWheelTarget === "filter") {
                    filterNodeRef.current.frequency.setTargetAtTime(getEffectiveCutoff(params), now, 0.05);
                }
                if (params.modWheelTarget === "amp") {
                    masterGainRef.current.gain.setTargetAtTime(clamp(params.volume + params.modWheel * 0.5, 0, 1.2), now, 0.05);
                }
                updateLfoDepth(params);
                break;
            case "modWheelTarget":
                voicesRef.current.forEach((voice) => updateVoiceDetune(voice, params));
                filterNodeRef.current.frequency.setTargetAtTime(getEffectiveCutoff(params), now, 0.05);
                masterGainRef.current.gain.setTargetAtTime(
                    clamp(params.volume + (params.modWheelTarget === "amp" ? params.modWheel * 0.5 : 0), 0, 1.2),
                    now,
                    0.05
                );
                updateLfoDepth(params);
                break;
                    case "filterType":
                        filterNodeRef.current.type = value;
                        break;
                    case "filterCutoff":
                        filterNodeRef.current.frequency.setTargetAtTime(getEffectiveCutoff(params), now, 0.05);
                        break;
                    case "filterResonance":
                        filterNodeRef.current.Q.setTargetAtTime(value, now, 0.05);
                        break;
                    case "filterEnvAmount":
                        break;
                    case "drive":
                        driveNodeRef.current.curve = makeDriveCurve(value);
                        break;
                    case "lfoEnabled":
                    case "lfoDepth":
                    case "lfoTarget":
                    case "lfoRate":
                    case "lfoWaveform":
                        lfoRef.current.osc.frequency.setTargetAtTime(params.lfoRate, now, 0.05);
                        lfoRef.current.osc.type = params.lfoWaveform;
                        updateLfoTarget(params.lfoTarget, true);
                        updateLfoDepth(params);
                        break;
                    case "chorusRate":
                        chorusRef.current.lfo.frequency.setTargetAtTime(value, now, 0.05);
                        break;
                    case "chorusDepth":
                        chorusRef.current.lfoGain.gain.setTargetAtTime(value * 0.02, now, 0.05);
                        break;
                    case "chorusMix":
                    case "delayMix":
                    case "bitMix":
                        applyEffectMixes(params);
                        break;
                    case "delayTime":
                        delayRef.current.delay.delayTime.setTargetAtTime(value, now, 0.05);
                        break;
                    case "delayFeedback":
                        delayRef.current.feedback.gain.setTargetAtTime(value, now, 0.05);
                        break;
                    case "bitDepth":
                    case "bitReduce":
                        bitCrusherMixRef.current.settings.bitDepth = params.bitDepth;
                        bitCrusherMixRef.current.settings.bitReduce = params.bitReduce;
                        break;
                    case "stereoWidth":
                        widthRef.current.delay.delayTime.setTargetAtTime(value * 0.02, now, 0.05);
                        break;
                    case "voiceMode":
                        if (value === "mono") {
                            releaseExtraVoices();
                        }
                        break;
                    default:
                        break;
                }
            }, []);

            const updateParam = React.useCallback((param, value) => {
                setSoundParams((prev) => {
                    const next = { ...prev, [param]: value };
                    if (isInitializedRef.current) {
                        applyParamToAudio(param, value, next);
                    }
                    return next;
                });
            }, [applyParamToAudio]);

            const updateSeqSteps = (index) => {
                setSoundParams((prev) => {
                    const nextSteps = [...prev.seqSteps];
                    const current = nextSteps[index];
                    const currentIndex = SEQ_OFFSETS.findIndex((value) => value === current);
                    const nextIndex = (currentIndex + 1) % SEQ_OFFSETS.length;
                    nextSteps[index] = SEQ_OFFSETS[nextIndex];
                    const next = { ...prev, seqSteps: nextSteps };
                    return next;
                });
            };

            const applyAllParams = React.useCallback((params) => {
                if (!isInitializedRef.current || !audioContextRef.current) return;
                const now = audioContextRef.current.currentTime;

        masterGainRef.current.gain.setTargetAtTime(
            clamp(params.volume + (params.modWheelTarget === "amp" ? params.modWheel * 0.5 : 0), 0, 1.2),
            now,
            0.02
        );
                dryGainRef.current.gain.setTargetAtTime(1 - params.reverb, now, 0.05);
                wetGainRef.current.gain.setTargetAtTime(params.reverb, now, 0.05);

                filterNodeRef.current.type = params.filterType;
                filterNodeRef.current.frequency.setTargetAtTime(getEffectiveCutoff(params), now, 0.05);
                filterNodeRef.current.Q.setTargetAtTime(params.filterResonance, now, 0.05);

                driveNodeRef.current.curve = makeDriveCurve(params.drive);
                chorusRef.current.lfo.frequency.setTargetAtTime(params.chorusRate, now, 0.05);
                chorusRef.current.lfoGain.gain.setTargetAtTime(params.chorusDepth * 0.02, now, 0.05);
                delayRef.current.delay.delayTime.setTargetAtTime(params.delayTime, now, 0.05);
                delayRef.current.feedback.gain.setTargetAtTime(params.delayFeedback, now, 0.05);
                widthRef.current.delay.delayTime.setTargetAtTime(params.stereoWidth * 0.02, now, 0.05);
                bitCrusherMixRef.current.settings.bitDepth = params.bitDepth;
                bitCrusherMixRef.current.settings.bitReduce = params.bitReduce;

                applyEffectMixes(params);

                voicesRef.current.forEach((voice) => rebuildVoiceOscillators(voice, params));
                voicesRef.current.forEach((voice) => updateVoiceDetune(voice, params));
                updateRootFrequency(params.frequency, params);

                if (params.voiceMode === "mono") {
                    releaseExtraVoices();
                }

                lfoRef.current.osc.frequency.setTargetAtTime(params.lfoRate, now, 0.05);
                lfoRef.current.osc.type = params.lfoWaveform;
                updateLfoTarget(params.lfoTarget, true);
                updateLfoDepth(params);
            }, []);

            const ensureAudioRunning = () => {
                if (!isInitializedRef.current) {
                    initializeAudio();
                }
                if (audioContextRef.current?.state === "suspended") {
                    return audioContextRef.current.resume();
                }
                return Promise.resolve();
            };

            const triggerMonoNote = (frequency, velocity = 1) => {
                const params = soundParamsRef.current;
                const rootVoice = ensureRootVoice(params);
                activeFrequencyRef.current = frequency;
                setDisplayFrequency(frequency);
                updateVoiceFrequency(rootVoice, frequency, params);
                triggerVoiceAttack(rootVoice, velocity);
            };

            const toggleSound = () => {
                const nextIsPlaying = !isPlayingRef.current;
                if (nextIsPlaying) {
                    ensureAudioRunning().then(() => {
                        const params = soundParamsRef.current;
                        const rootVoice = ensureRootVoice(params);
                        updateRootFrequency(params.frequency, params);
                        triggerVoiceAttack(rootVoice, 1);
                        masterGainRef.current.gain.setTargetAtTime(params.volume, audioContextRef.current.currentTime, 0.02);
                        if (params.arpEnabled && !params.seqEnabled) {
                            startArp();
                        }
                        if (params.seqEnabled) {
                            startSequencer();
                        }
                        hasStartedRef.current = true;
                    });
                } else {
                    stopArp(soundParamsRef.current.frequency);
                    stopSequencer();
                    releaseAllVoices();
                }
                setIsPlaying(nextIsPlaying);
                hapticPulse(8);
            };

            const panicAll = () => {
                if (!isInitializedRef.current) return;
                masterGainRef.current.gain.setTargetAtTime(0, audioContextRef.current.currentTime, 0.01);
                stopArp(soundParamsRef.current.frequency);
                stopSequencer();
                releaseAllVoices();
                setIsPlaying(false);
                flashMessage("All sound muted");
            };

            const randomizeParams = () => {
                const randomWaveform = WAVEFORMS[Math.floor(Math.random() * WAVEFORMS.length)];
                const randomFilter = FILTER_TYPES[Math.floor(Math.random() * FILTER_TYPES.length)];
                const randomPattern = ARP_PATTERNS[Math.floor(Math.random() * ARP_PATTERNS.length)];

                const newParams = {
                    ...soundParamsRef.current,
                    frequency: sliderToFreq(Math.random()),
                    volume: 0.2 + Math.random() * 0.7,
                    reverb: Math.random() * 0.8,
                    complexity: Math.random(),
                    waveform: randomWaveform,
                    attack: 0.01 + Math.random() * 0.4,
                    decay: 0.05 + Math.random() * 0.8,
                    sustain: 0.3 + Math.random() * 0.6,
                    release: 0.1 + Math.random() * 1.0,
                    filterType: randomFilter,
                    filterCutoff: sliderToCutoff(Math.random()),
                    filterResonance: 0.2 + Math.random() * 10,
                    filterEnvAmount: Math.random(),
                    detune: -10 + Math.random() * 20,
                    unisonCount: Math.ceil(Math.random() * 4),
                    unisonSpread: 5 + Math.random() * 15,
                    subLevel: Math.random() * 0.4,
                    noiseLevel: Math.random() * 0.2,
                    glide: Math.random() * 0.2,
                    lfoEnabled: Math.random() > 0.5,
                    lfoRate: 0.5 + Math.random() * 6,
                    lfoDepth: Math.random() * 0.6,
                    lfoTarget: LFO_TARGETS[Math.floor(Math.random() * LFO_TARGETS.length)],
                    drive: Math.random() * 0.6,
                    chorusMix: Math.random() * 0.4,
                    delayMix: Math.random() * 0.3,
                    bitMix: Math.random() * 0.2,
                    stereoWidth: Math.random() * 0.5,
                    arpEnabled: Math.random() > 0.8,
                    arpRate: 80 + Math.random() * 120,
                    arpPattern: randomPattern
                };

                soundParamsRef.current = newParams;
                setSoundParams(newParams);
                if (isInitializedRef.current) {
                    applyAllParams(newParams);
                }
                if (newParams.arpEnabled && isPlayingRef.current && !newParams.seqEnabled) {
                    startArp();
                } else {
                    stopArp(newParams.frequency);
                }
                hapticPulse(10);
            };

            const copyShareLink = async () => {
                const url = window.location.href;
                try {
                    await navigator.clipboard.writeText(url);
                    flashMessage("Link copied");
                } catch (error) {
                    window.prompt("Copy this link:", url);
                }
            };

            const renderOfflineBuffer = async (params, durationSeconds) => {
                const OfflineContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;
                if (!OfflineContext) {
                    throw new Error("OfflineAudioContext not supported");
                }
                const duration = clamp(durationSeconds, 1, MAX_EXPORT_DURATION);
                const sampleRate = audioContextRef.current?.sampleRate || 44100;
                const frameCount = Math.ceil(duration * sampleRate);
                const ctx = new OfflineContext(2, frameCount, sampleRate);

                const voiceBusGain = ctx.createGain();
                const driveNode = ctx.createWaveShaper();
                const filterNode = ctx.createBiquadFilter();
                const limiterNode = ctx.createDynamicsCompressor();
                const masterGain = ctx.createGain();
                const reverbNode = ctx.createConvolver();
                const dryGain = ctx.createGain();
                const wetGain = ctx.createGain();
                const mixBus = ctx.createGain();

                const setupBitCrusher = () => {
                    const input = ctx.createGain();
                    const output = ctx.createGain();
                    if (!ctx.createScriptProcessor || params.bitMix <= 0) {
                        input.connect(output);
                        return { input, output };
                    }

                    try {
                        const dry = ctx.createGain();
                        const wet = ctx.createGain();
                        const node = ctx.createScriptProcessor(4096, 1, 1);
                        const settings = { bitDepth: params.bitDepth, bitReduce: params.bitReduce };
                        let phaser = 0;
                        let lastSample = 0;

                        node.onaudioprocess = (event) => {
                            const inputBuffer = event.inputBuffer.getChannelData(0);
                            const outputBuffer = event.outputBuffer.getChannelData(0);
                            const step = Math.pow(0.5, settings.bitDepth);
                            const reduction = 1 / Math.max(1, settings.bitReduce);
                            for (let i = 0; i < inputBuffer.length; i++) {
                                phaser += reduction;
                                if (phaser >= 1.0) {
                                    phaser -= 1.0;
                                    lastSample = Math.round(inputBuffer[i] / step) * step;
                                }
                                outputBuffer[i] = lastSample;
                            }
                        };

                        input.connect(dry);
                        input.connect(node);
                        node.connect(wet);
                        dry.connect(output);
                        wet.connect(output);

                        dry.gain.setValueAtTime(1 - params.bitMix, 0);
                        wet.gain.setValueAtTime(params.bitMix, 0);

                        return { input, output, dry, wet };
                    } catch (error) {
                        input.connect(output);
                        return { input, output };
                    }
                };

                const setupChorus = () => {
                    const input = ctx.createGain();
                    const output = ctx.createGain();
                    const dry = ctx.createGain();
                    const wet = ctx.createGain();
                    const delay = ctx.createDelay(0.05);
                    const lfo = ctx.createOscillator();
                    const lfoGain = ctx.createGain();

                    lfo.type = "sine";
                    lfo.frequency.setValueAtTime(params.chorusRate, 0);
                    lfoGain.gain.setValueAtTime(params.chorusDepth * 0.015, 0);
                    delay.delayTime.setValueAtTime(0.015, 0);

                    lfo.connect(lfoGain);
                    lfoGain.connect(delay.delayTime);
                    lfo.start(0);

                    input.connect(dry);
                    input.connect(delay);
                    delay.connect(wet);
                    dry.connect(output);
                    wet.connect(output);

                    dry.gain.setValueAtTime(1 - params.chorusMix, 0);
                    wet.gain.setValueAtTime(params.chorusMix, 0);

                    return { input, output, dry, wet, lfo, lfoGain };
                };

                const setupDelay = () => {
                    const input = ctx.createGain();
                    const output = ctx.createGain();
                    const dry = ctx.createGain();
                    const wet = ctx.createGain();
                    const delay = ctx.createDelay(1.2);
                    const feedback = ctx.createGain();

                    delay.delayTime.setValueAtTime(params.delayTime, 0);
                    feedback.gain.setValueAtTime(params.delayFeedback, 0);

                    input.connect(dry);
                    input.connect(delay);
                    delay.connect(feedback);
                    feedback.connect(delay);
                    delay.connect(wet);
                    dry.connect(output);
                    wet.connect(output);

                    dry.gain.setValueAtTime(1 - params.delayMix, 0);
                    wet.gain.setValueAtTime(params.delayMix, 0);

                    return { input, output, dry, wet, delay, feedback };
                };

                const setupWidth = () => {
                    const splitter = ctx.createChannelSplitter(2);
                    const merger = ctx.createChannelMerger(2);
                    const delay = ctx.createDelay(0.05);
                    delay.delayTime.setValueAtTime(params.stereoWidth * 0.02, 0);
                    return { splitter, delay, merger };
                };

                const bitCrusher = setupBitCrusher();
                const chorus = setupChorus();
                const delay = setupDelay();
                const width = setupWidth();

                const lfo = { osc: ctx.createOscillator(), gain: ctx.createGain() };
                lfo.osc.type = params.lfoWaveform;
                lfo.osc.frequency.setValueAtTime(params.lfoRate, 0);
                lfo.gain.gain.setValueAtTime(0, 0);
                lfo.osc.connect(lfo.gain);
                lfo.osc.start(0);

                const updateRenderLfoDepth = () => {
                    if (!params.lfoEnabled) {
                        lfo.gain.gain.setValueAtTime(0, 0);
                        return;
                    }
                    const wheelBoost = params.modWheelTarget === "lfo" ? 1 + params.modWheel : 1;
                    const depth = params.lfoDepth * wheelBoost;
                    let gainValue = 0;
                    if (params.lfoTarget === "pitch") {
                        gainValue = depth * 40;
                    } else if (params.lfoTarget === "filter") {
                        gainValue = depth * 2000;
                    } else {
                        gainValue = depth * 0.5;
                    }
                    lfo.gain.gain.setValueAtTime(gainValue, 0);
                };

                const modBoost = params.modWheelTarget === "amp" ? params.modWheel * 0.5 : 0;

                voiceBusGain.gain.setValueAtTime(1, 0);
                masterGain.gain.setValueAtTime(clamp(params.volume + modBoost, 0, 1.2), 0);
                driveNode.curve = makeDriveCurve(params.drive);
                driveNode.oversample = "4x";
                filterNode.type = params.filterType;
                filterNode.frequency.setValueAtTime(getEffectiveCutoff(params), 0);
                filterNode.Q.setValueAtTime(params.filterResonance, 0);
                limiterNode.threshold.setValueAtTime(-6, 0);
                limiterNode.knee.setValueAtTime(0, 0);
                limiterNode.ratio.setValueAtTime(12, 0);
                limiterNode.attack.setValueAtTime(0.003, 0);
                limiterNode.release.setValueAtTime(0.25, 0);
                reverbNode.buffer = createImpulseResponseForContext(ctx, 2.2);
                dryGain.gain.setValueAtTime(1 - params.reverb, 0);
                wetGain.gain.setValueAtTime(params.reverb, 0);

                voiceBusGain.connect(driveNode);
                driveNode.connect(filterNode);
                filterNode.connect(bitCrusher.input);
                bitCrusher.output.connect(chorus.input);
                chorus.output.connect(delay.input);
                delay.output.connect(limiterNode);
                limiterNode.connect(masterGain);

                masterGain.connect(dryGain);
                masterGain.connect(reverbNode);
                reverbNode.connect(wetGain);
                dryGain.connect(mixBus);
                wetGain.connect(mixBus);

                mixBus.connect(width.splitter);
                width.splitter.connect(width.merger, 0, 0);
                width.splitter.connect(width.delay, 1);
                width.delay.connect(width.merger, 0, 1);
                width.merger.connect(ctx.destination);

                updateRenderLfoDepth();
                if (params.lfoTarget === "filter") {
                    lfo.gain.connect(filterNode.frequency);
                } else if (params.lfoTarget === "amp") {
                    lfo.gain.connect(masterGain.gain);
                }

                const noiseBuffer = params.noiseLevel > 0 ? createNoiseBufferForContext(ctx) : null;

                const createRenderOscillatorSet = (baseFreq, envelopeGain) => {
                    const oscillators = [];
                    const numHarmonics = getHarmonicsCount(params.complexity);
                    const unisonCount = Math.max(1, params.unisonCount);
                    const spread = params.unisonSpread;
                    const detuneBase = params.detune + (params.modWheelTarget === "pitch" ? params.modWheel * 30 : 0);

                    for (let i = 0; i < numHarmonics; i++) {
                        const harmonicIndex = i + 1;
                        const baseHarmonic = baseFreq * harmonicIndex;
                        for (let u = 0; u < unisonCount; u++) {
                            const osc = ctx.createOscillator();
                            osc.type = params.waveform;
                            const detuneOffset = unisonCount === 1
                                ? 0
                                : (u - (unisonCount - 1) / 2) * (spread * 2);
                            osc.detune.setValueAtTime(detuneBase + detuneOffset, 0);
                            osc.frequency.setValueAtTime(baseHarmonic, 0);

                            let gainNode = null;
                            if (i === 0) {
                                if (unisonCount > 1) {
                                    gainNode = ctx.createGain();
                                    gainNode.gain.setValueAtTime(1 / unisonCount, 0);
                                    osc.connect(gainNode);
                                    gainNode.connect(envelopeGain);
                                } else {
                                    osc.connect(envelopeGain);
                                }
                            } else {
                                gainNode = ctx.createGain();
                                const amplitude = Math.pow(0.5, i) * (1 - params.complexity * 0.3) * (1 / unisonCount);
                                gainNode.gain.setValueAtTime(amplitude, 0);
                                osc.connect(gainNode);
                                gainNode.connect(envelopeGain);
                            }

                            if (params.lfoTarget === "pitch") {
                                lfo.gain.connect(osc.detune);
                            }

                            osc.start(0);
                            oscillators.push({ osc, gainNode, harmonicIndex, detuneOffset });
                        }
                    }

                    return oscillators;
                };

                const createRenderVoice = (frequency) => {
                    const envelopeGain = ctx.createGain();
                    envelopeGain.gain.setValueAtTime(0, 0);
                    envelopeGain.connect(voiceBusGain);

                    const oscillators = createRenderOscillatorSet(frequency, envelopeGain);

                    let subOsc = null;
                    let subGain = null;
                    if (params.subLevel > 0) {
                        subOsc = ctx.createOscillator();
                        subGain = ctx.createGain();
                        subOsc.type = "sine";
                        subOsc.frequency.setValueAtTime(frequency * 0.5, 0);
                        subGain.gain.setValueAtTime(params.subLevel, 0);
                        subOsc.connect(subGain);
                        subGain.connect(envelopeGain);
                        subOsc.start(0);
                    }

                    let noiseSource = null;
                    let noiseGain = null;
                    if (params.noiseLevel > 0 && noiseBuffer) {
                        noiseSource = ctx.createBufferSource();
                        noiseSource.buffer = noiseBuffer;
                        noiseSource.loop = true;
                        noiseGain = ctx.createGain();
                        noiseGain.gain.setValueAtTime(params.noiseLevel, 0);
                        noiseSource.connect(noiseGain);
                        noiseGain.connect(envelopeGain);
                        noiseSource.start(0);
                    }

                    return {
                        envelopeGain,
                        oscillators,
                        subOsc,
                        subGain,
                        noiseSource,
                        noiseGain,
                        currentFrequency: frequency
                    };
                };

                const scheduleFilterEnvelope = (time, velocity = 1) => {
                    const baseCutoff = getEffectiveCutoff(params);
                    const envAmount = params.filterEnvAmount;
                    if (envAmount <= 0) {
                        filterNode.frequency.setValueAtTime(baseCutoff, time);
                        return;
                    }
                    const velocityScale = 1 - params.velocityAmount + params.velocityAmount * velocity;
                    const peak = baseCutoff * Math.pow(2, envAmount * 2 * velocityScale);
                    const sustain = baseCutoff + (peak - baseCutoff) * params.sustain;
                    const attackEnd = time + params.attack;
                    const decayEnd = attackEnd + params.decay;

                    filterNode.frequency.setValueAtTime(baseCutoff, time);
                    filterNode.frequency.linearRampToValueAtTime(peak, attackEnd);
                    filterNode.frequency.linearRampToValueAtTime(sustain, decayEnd);
                };

                const scheduleFilterRelease = (time) => {
                    filterNode.frequency.setTargetAtTime(getEffectiveCutoff(params), time, params.release);
                };

                const scheduleVoiceAttack = (voice, time, velocity = 1) => {
                    const gain = voice.envelopeGain.gain;
                    const velocityScale = 1 - params.velocityAmount + params.velocityAmount * velocity;
                    const peak = clamp(velocityScale, 0, 1);

                    gain.setValueAtTime(0, time);
                    gain.linearRampToValueAtTime(peak, time + params.attack);
                    gain.linearRampToValueAtTime(peak * params.sustain, time + params.attack + params.decay);
                    scheduleFilterEnvelope(time, velocity);
                };

                const scheduleVoiceRelease = (time) => {
                    const gain = voice.envelopeGain.gain;
                    gain.linearRampToValueAtTime(0, time + params.release);
                    scheduleFilterRelease(time);
                };

                const scheduleVoiceFrequency = (voice, frequency, time) => {
                    const glide = params.glide;
                    const baseStart = voice.currentFrequency;
                    voice.currentFrequency = frequency;
                    voice.oscillators.forEach(({ osc, harmonicIndex }) => {
                        const start = baseStart * harmonicIndex;
                        const target = frequency * harmonicIndex;
                        if (glide > 0) {
                            osc.frequency.setValueAtTime(start, time);
                            osc.frequency.linearRampToValueAtTime(target, time + glide);
                        } else {
                            osc.frequency.setValueAtTime(target, time);
                        }
                    });
                    if (voice.subOsc) {
                        const start = baseStart * 0.5;
                        const target = frequency * 0.5;
                        if (glide > 0) {
                            voice.subOsc.frequency.setValueAtTime(start, time);
                            voice.subOsc.frequency.linearRampToValueAtTime(target, time + glide);
                        } else {
                            voice.subOsc.frequency.setValueAtTime(target, time);
                        }
                    }
                };

                const voice = createRenderVoice(params.frequency);
                scheduleVoiceAttack(voice, 0, 1);

                const releaseStart = Math.max(0, duration - params.release - 0.05);

                if (params.seqEnabled) {
                    let time = 0;
                    let step = 0;
                    const stepDuration = 60 / params.seqRate;
                    const steps = params.seqSteps.slice(0, params.seqLength);

                    while (time < duration) {
                        const index = step % steps.length;
                        const stepValue = steps[index];
                        const isOdd = step % 2 === 1;
                        const swingFactor = isOdd ? 1 + params.seqSwing : 1 - params.seqSwing;
                        const interval = stepDuration * swingFactor;

                        if (stepValue !== null && Math.random() <= params.seqProbability) {
                            const freq = params.frequency * Math.pow(2, stepValue / 12);
                            scheduleVoiceFrequency(voice, freq, time);
                            scheduleVoiceAttack(voice, time, 1);
                            if (!params.seqHold) {
                                const gate = stepDuration * params.seqGate;
                                scheduleVoiceRelease(voice, Math.min(time + gate, duration));
                            }
                        }

                        time += interval;
                        step += 1;
                    }

                    scheduleVoiceRelease(voice, releaseStart);
                } else if (params.arpEnabled) {
                    const scale = [0, 4, 7, 12];
                    let time = 0;
                    let step = 0;
                    const interval = 60 / params.arpRate;

                    while (time < duration) {
                        let offset = 0;
                        if (params.arpPattern === "random") {
                            offset = scale[Math.floor(Math.random() * scale.length)];
                        } else if (params.arpPattern === "down") {
                            offset = scale[scale.length - 1 - (step % scale.length)];
                        } else {
                            offset = scale[step % scale.length];
                        }
                        const freq = params.frequency * Math.pow(2, offset / 12);
                        scheduleVoiceFrequency(voice, freq, time);
                        time += interval;
                        step += 1;
                    }

                    scheduleVoiceRelease(voice, releaseStart);
                } else {
                    scheduleVoiceRelease(voice, releaseStart);
                }

                return ctx.startRendering();
            };

            const exportAudio = async () => {
                if (isExporting) return;
                const duration = clamp(Math.round(exportDuration), 1, MAX_EXPORT_DURATION);
                if (duration !== exportDuration) {
                    setExportDuration(duration);
                }
                setIsExporting(true);
                if (messageTimerRef.current) {
                    clearTimeout(messageTimerRef.current);
                    messageTimerRef.current = null;
                }
                setStatusMessage("Rendering...");

                try {
                    const params = { ...soundParamsRef.current };
                    const buffer = await renderOfflineBuffer(params, duration);
                    const wavBlob = encodeWav(buffer);
                    const stamp = new Date().toISOString().replace(/[:.]/g, "-");
                    triggerDownload(wavBlob, `simplesynth-${duration}s-${stamp}.wav`);
                    flashMessage("Export ready");
                } catch (error) {
                    console.error(error);
                    flashMessage("Export failed");
                } finally {
                    setIsExporting(false);
                }
            };

            const advanceArpStep = () => {
                const params = soundParamsRef.current;
                const scale = [0, 4, 7, 12];
                let offset = 0;

                if (params.arpPattern === "random") {
                    offset = scale[Math.floor(Math.random() * scale.length)];
                } else if (params.arpPattern === "down") {
                    offset = scale[scale.length - 1 - (arpStepRef.current % scale.length)];
                } else {
                    offset = scale[arpStepRef.current % scale.length];
                }

                arpStepRef.current = (arpStepRef.current + 1) % scale.length;
                arpOffsetRef.current = offset;
                updateRootFrequency(params.frequency, params);
            };

            const startArp = () => {
                stopArp(soundParamsRef.current.frequency);
                arpStepRef.current = 0;
                advanceArpStep();
                const interval = (60 / soundParamsRef.current.arpRate) * 1000;
                arpTimerRef.current = setInterval(advanceArpStep, interval);
            };

            const stopArp = (rootFrequency) => {
                if (arpTimerRef.current) {
                    clearInterval(arpTimerRef.current);
                    arpTimerRef.current = null;
                }
                arpOffsetRef.current = 0;
                arpStepRef.current = 0;
                updateRootFrequency(rootFrequency, {
                    ...soundParamsRef.current,
                    arpEnabled: false
                });
            };

            const scheduleSeqStep = () => {
                const params = soundParamsRef.current;
                if (!params.seqEnabled || !isPlayingRef.current) return;

                const stepDuration = (60 / params.seqRate) * 1000;
                const swingAmount = params.seqSwing;
                const isOdd = seqStepRef.current % 2 === 1;
                const swingFactor = isOdd ? 1 + swingAmount : 1 - swingAmount;
                const interval = stepDuration * swingFactor;

                const index = seqStepRef.current % params.seqLength;
                const stepValue = params.seqSteps[index];
                seqStepRef.current = (seqStepRef.current + 1) % params.seqLength;

                if (stepValue !== null && Math.random() <= params.seqProbability) {
                    const freq = params.frequency * Math.pow(2, stepValue / 12);
                    triggerMonoNote(freq, 1);
                    if (!params.seqHold) {
                        const gate = stepDuration * params.seqGate;
                        if (seqReleaseRef.current) {
                            clearTimeout(seqReleaseRef.current);
                        }
                        seqReleaseRef.current = setTimeout(() => {
                            const voice = voicesRef.current.get(rootVoiceIdRef.current);
                            if (voice) {
                                triggerVoiceRelease(voice);
                            }
                        }, gate);
                    }
                }

                seqTimerRef.current = setTimeout(scheduleSeqStep, interval);
            };

            const startSequencer = () => {
                stopSequencer();
                seqStepRef.current = 0;
                scheduleSeqStep();
            };

            const stopSequencer = () => {
                if (seqTimerRef.current) {
                    clearTimeout(seqTimerRef.current);
                    seqTimerRef.current = null;
                }
                if (seqReleaseRef.current) {
                    clearTimeout(seqReleaseRef.current);
                    seqReleaseRef.current = null;
                }
            };

            React.useEffect(() => {
                if (!soundParams.arpEnabled || !isPlaying || soundParams.seqEnabled) {
                    stopArp(soundParams.frequency);
                    return;
                }
                startArp();
                return () => stopArp(soundParams.frequency);
            }, [soundParams.arpEnabled, soundParams.arpRate, soundParams.arpPattern, soundParams.frequency, soundParams.seqEnabled, isPlaying]);

            React.useEffect(() => {
                if (!soundParams.seqEnabled || !isPlaying) {
                    stopSequencer();
                    return;
                }
                startSequencer();
                return () => stopSequencer();
            }, [soundParams.seqEnabled, soundParams.seqRate, soundParams.seqLength, soundParams.seqGate, soundParams.seqSwing, soundParams.seqHold, soundParams.seqProbability, soundParams.seqSteps, isPlaying]);

            const handlePresetSave = () => {
                const trimmed = presetName.trim();
                if (!trimmed) {
                    flashMessage("Name your preset");
                    return;
                }

                const tags = presetTags
                    .split(",")
                    .map((tag) => tag.trim())
                    .filter(Boolean);

                const nextPreset = {
                    name: trimmed,
                    tags,
                    params: { ...soundParamsRef.current },
                    visualizerMode
                };

                setPresets((prev) => {
                    const index = prev.findIndex((preset) => preset.name === trimmed);
                    const updated = [...prev];
                    if (index >= 0) {
                        updated[index] = nextPreset;
                    } else {
                        updated.push(nextPreset);
                    }
                    return updated;
                });

                setSelectedPreset(trimmed);
                flashMessage("Preset saved");
            };

            const handlePresetLoad = () => {
                const preset = presets.find((item) => item.name === selectedPreset);
                if (!preset) {
                    flashMessage("Select a preset");
                    return;
                }

                const nextParams = { ...DEFAULT_PARAMS, ...preset.params };
                soundParamsRef.current = nextParams;
                setSoundParams(nextParams);
                setVisualizerMode(preset.visualizerMode || DEFAULT_VISUALIZER);
                applyAllParams(nextParams);
                if (nextParams.arpEnabled && isPlayingRef.current && !nextParams.seqEnabled) {
                    startArp();
                } else {
                    stopArp(nextParams.frequency);
                }
                flashMessage("Preset loaded");
            };

            const handlePresetDelete = () => {
                if (!selectedPreset) {
                    flashMessage("Select a preset");
                    return;
                }

                setPresets((prev) => prev.filter((preset) => preset.name !== selectedPreset));
                setSelectedPreset("");
                flashMessage("Preset removed");
            };

            const exportPresets = () => {
                const payload = JSON.stringify(presets, null, 2);
                const blob = new Blob([payload], { type: "application/json" });
                triggerDownload(blob, "simple-synth-presets.json");
                flashMessage("Preset export ready");
            };

            const importPresets = (event) => {
                const file = event.target.files?.[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = () => {
                    try {
                        const imported = JSON.parse(reader.result);
                        if (Array.isArray(imported)) {
                            setPresets((prev) => [...prev, ...imported]);
                            flashMessage("Presets imported");
                        } else {
                            flashMessage("Invalid preset file");
                        }
                    } catch (error) {
                        flashMessage("Invalid preset file");
                    }
                    event.target.value = "";
                };
                reader.readAsText(file);
            };

            const handleKeyDown = React.useCallback((event) => {
                if (event.repeat) return;
                const tag = event.target.tagName;
                if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT") return;

                const key = event.key.toLowerCase();
                const keyMap = {
                    a: 0,
                    s: 2,
                    d: 4,
                    f: 5,
                    g: 7,
                    h: 9,
                    j: 11,
                    k: 12
                };

                if (key === "z") {
                    setKeyboardOctave((prev) => clamp(prev - 1, 1, 7));
                    hapticPulse(8);
                    return;
                }

                if (key === "x") {
                    setKeyboardOctave((prev) => clamp(prev + 1, 1, 7));
                    hapticPulse(8);
                    return;
                }

                if (keyMap[key] !== undefined) {
                    const baseMidi = 60 + (keyboardOctaveRef.current - 4) * 12;
                    const midi = baseMidi + keyMap[key];
                    const freq = 440 * Math.pow(2, (midi - 69) / 12);
                    const clamped = clamp(freq, MIN_FREQ, MAX_FREQ);

                    if (soundParamsRef.current.voiceMode === "poly" && isPlayingRef.current) {
                        if (!activeKeyVoicesRef.current.has(key)) {
                            const id = generateVoiceId(`key-${key}`);
                            const voice = createVoice(clamped, soundParamsRef.current, id, 1);
                            voicesRef.current.set(id, voice);
                            activeKeyVoicesRef.current.set(key, id);
                            triggerVoiceAttack(voice, 1);
                        }
                    } else {
                        updateParam("frequency", clamped);
                        if (isPlayingRef.current) {
                            triggerMonoNote(clamped, 1);
                        }
                    }
                }
            }, [updateParam]);

            const handleKeyUp = React.useCallback((event) => {
                const key = event.key.toLowerCase();
                const voiceId = activeKeyVoicesRef.current.get(key);
                if (!voiceId) return;
                const voice = voicesRef.current.get(voiceId);
                if (voice) {
                    triggerVoiceRelease(voice);
                }
                activeKeyVoicesRef.current.delete(key);
            }, []);

            React.useEffect(() => {
                window.addEventListener("keydown", handleKeyDown);
                window.addEventListener("keyup", handleKeyUp);
                return () => {
                    window.removeEventListener("keydown", handleKeyDown);
                    window.removeEventListener("keyup", handleKeyUp);
                };
            }, [handleKeyDown, handleKeyUp]);

            const handleMidiMessage = (event) => {
                const [status, note, velocity] = event.data;
                const command = status & 0xf0;
                if (command === 0x90 && velocity > 0) {
                    const freq = 440 * Math.pow(2, (note - 69) / 12);
                    ensureAudioRunning().then(() => {
                        const id = generateVoiceId(`midi-${note}`);
                        const voice = createVoice(freq, soundParamsRef.current, id, velocity / 127);
                        voicesRef.current.set(id, voice);
                        midiVoicesRef.current.set(note, id);
                        triggerVoiceAttack(voice, velocity / 127);
                        setIsPlaying(true);
                    });
                } else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
                    const id = midiVoicesRef.current.get(note);
                    if (id) {
                        const voice = voicesRef.current.get(id);
                        if (voice) triggerVoiceRelease(voice);
                        midiVoicesRef.current.delete(note);
                    }
                } else if (command === 0xB0 && note === 1) {
                    updateParam("modWheel", velocity / 127);
                }
            };

            const toggleMidi = () => {
                if (soundParamsRef.current.midiEnabled) {
                    midiAccessRef.current?.inputs?.forEach((input) => (input.onmidimessage = null));
                    updateParam("midiEnabled", false);
                    return;
                }

                if (!navigator.requestMIDIAccess) {
                    flashMessage("MIDI not supported");
                    return;
                }

                navigator.requestMIDIAccess().then((access) => {
                    midiAccessRef.current = access;
                    access.inputs.forEach((input) => {
                        input.onmidimessage = handleMidiMessage;
                    });
                    updateParam("midiEnabled", true);
                    flashMessage("MIDI enabled");
                }).catch(() => flashMessage("MIDI access denied"));
            };

            React.useEffect(() => {
                const waveformCanvas = waveformCanvasRef.current;
                const spectrumCanvas = spectrumCanvasRef.current;
                const vuCanvas = vuCanvasRef.current;
                if (!waveformCanvas && !spectrumCanvas && !vuCanvas) return;

                const waveformCtx = waveformCanvas ? waveformCanvas.getContext("2d") : null;
                const spectrumCtx = spectrumCanvas ? spectrumCanvas.getContext("2d") : null;
                const vuCtx = vuCanvas ? vuCanvas.getContext("2d") : null;

                const resizeCanvas = (canvas, ctx) => {
                    if (!canvas || !ctx) return;
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
                    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                };

                const drawWaveform = (ctx, dataArray, width, height) => {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "rgba(110, 199, 255, 0.9)";
                    ctx.beginPath();
                    const sliceWidth = width / (dataArray.length - 1);
                    let x = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        const v = dataArray[i] / 255.0;
                        const y = v * height;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        x += sliceWidth;
                    }
                    ctx.stroke();
                };

                const drawSpectrum = (ctx, dataArray, width, height) => {
                    const bars = 64;
                    const step = Math.floor(dataArray.length / bars);
                    const barWidth = width / bars;
                    for (let i = 0; i < bars; i++) {
                        const value = dataArray[i * step] / 255;
                        const barHeight = value * height;
                        const x = i * barWidth;
                        const y = height - barHeight;
                        ctx.fillStyle = `rgba(249, 168, 38, ${0.3 + value * 0.7})`;
                        ctx.fillRect(x, y, barWidth * 0.8, barHeight);
                    }
                };

                const render = () => {
                    const analyser = analyserNodeRef.current;

                    if (waveformCanvas && waveformCtx) {
                        const width = waveformCanvas.clientWidth;
                        const height = waveformCanvas.clientHeight;
                        waveformCtx.clearRect(0, 0, width, height);
                        waveformCtx.fillStyle = "rgba(6, 10, 24, 0.95)";
                        waveformCtx.fillRect(0, 0, width, height);

                        if (analyser) {
                            const bufferLength = analyser.frequencyBinCount;
                            if (!analyserBufferRef.current.waveform || analyserBufferRef.current.waveform.length !== bufferLength) {
                                analyserBufferRef.current.waveform = new Uint8Array(bufferLength);
                            }
                            analyser.getByteTimeDomainData(analyserBufferRef.current.waveform);
                            drawWaveform(waveformCtx, analyserBufferRef.current.waveform, width, height);
                        }
                    }

                    if (spectrumCanvas && spectrumCtx) {
                        const width = spectrumCanvas.clientWidth;
                        const height = spectrumCanvas.clientHeight;
                        spectrumCtx.clearRect(0, 0, width, height);
                        spectrumCtx.fillStyle = "rgba(6, 10, 24, 0.95)";
                        spectrumCtx.fillRect(0, 0, width, height);

                        if (analyser) {
                            const bufferLength = analyser.frequencyBinCount;
                            if (!analyserBufferRef.current.spectrum || analyserBufferRef.current.spectrum.length !== bufferLength) {
                                analyserBufferRef.current.spectrum = new Uint8Array(bufferLength);
                            }
                            analyser.getByteFrequencyData(analyserBufferRef.current.spectrum);
                            drawSpectrum(spectrumCtx, analyserBufferRef.current.spectrum, width, height);
                        }
                    }

                    if (vuCanvas && vuCtx) {
                        const width = vuCanvas.clientWidth;
                        const height = vuCanvas.clientHeight;
                        vuCtx.clearRect(0, 0, width, height);
                        vuCtx.fillStyle = "rgba(6, 10, 24, 0.95)";
                        vuCtx.fillRect(0, 0, width, height);

                        let level = 0;
                        if (analyser) {
                            const bufferLength = analyser.frequencyBinCount;
                            if (!analyserBufferRef.current.waveform || analyserBufferRef.current.waveform.length !== bufferLength) {
                                analyserBufferRef.current.waveform = new Uint8Array(bufferLength);
                            }
                            analyser.getByteTimeDomainData(analyserBufferRef.current.waveform);
                            const data = analyserBufferRef.current.waveform;
                            let sum = 0;
                            for (let i = 0; i < data.length; i++) {
                                const v = (data[i] - 128) / 128;
                                sum += v * v;
                            }
                            const rms = Math.sqrt(sum / data.length);
                            level = clamp(rms * 1.6, 0, 1);
                        }

                        const meterHeight = height * level;
                        const gradient = vuCtx.createLinearGradient(0, height, 0, 0);
                        gradient.addColorStop(0, "rgba(45, 212, 191, 0.85)");
                        gradient.addColorStop(0.6, "rgba(249, 239, 87, 0.85)");
                        gradient.addColorStop(0.85, "rgba(246, 160, 33, 0.9)");
                        gradient.addColorStop(1, "rgba(239, 68, 68, 0.95)");
                        vuCtx.fillStyle = gradient;
                        vuCtx.fillRect(6, height - meterHeight, width - 12, meterHeight);

                        vuCtx.strokeStyle = "rgba(148, 163, 184, 0.2)";
                        vuCtx.lineWidth = 1;
                        vuCtx.strokeRect(6, 6, width - 12, height - 12);
                    }

                    animationRef.current = requestAnimationFrame(render);
                };

                const handleResize = () => {
                    resizeCanvas(waveformCanvas, waveformCtx);
                    resizeCanvas(spectrumCanvas, spectrumCtx);
                    resizeCanvas(vuCanvas, vuCtx);
                };

                handleResize();
                window.addEventListener("resize", handleResize);
                render();

                return () => {
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                    window.removeEventListener("resize", handleResize);
                };
            }, []);

            const filteredPresets = presets.filter((preset) => {
                if (!presetFilter.trim()) return true;
                const query = presetFilter.trim().toLowerCase();
                const nameMatch = preset.name.toLowerCase().includes(query);
                const tagMatch = (preset.tags || []).some((tag) => tag.toLowerCase().includes(query));
                return nameMatch || tagMatch;
            });

            return (
                <div className="synth-container" data-performance={soundParams.performanceMode ? "true" : "false"}>
                    <div className="synth-card">
                        <div className="synth-header">
                            <div className="header-title">
                                <div className="title-eyebrow">Apollo x8 Rack</div>
                                <div className="synth-title">SimpleSynth</div>
                                <p className="synth-subtitle">
                                    Sculpt harmonics, envelopes, filters, and sequences in a rack-style channel matrix.
                                </p>
                            </div>
                            <div className="header-right">
                                <div className="scope-row">
                                    <div className="visualizer-card compact vu-card">
                                        <div className="visualizer-header">
                                            <div className="visualizer-title">
                                                <div className="control-title">VU</div>
                                            </div>
                                        </div>
                                        <div className="vu-meter">
                                            <canvas ref={vuCanvasRef} style={{ width: "100%", height: "100%" }} />
                                        </div>
                                    </div>
                                    <div className="visualizer-card compact">
                                        <div className="visualizer-header">
                                            <div className="visualizer-title">
                                                <div className="control-title">Waveform</div>
                                                <span className="mono">{formatFrequency(displayFrequency)}</span>
                                            </div>
                                        </div>
                                        <div className="visualizer">
                                            <canvas ref={waveformCanvasRef} style={{ width: "100%", height: "100%" }} />
                                        </div>
                                    </div>
                                    <div className="visualizer-card compact">
                                        <div className="visualizer-header">
                                            <div className="visualizer-title">
                                                <div className="control-title">Spectrum</div>
                                                <span className="mono">Hz</span>
                                            </div>
                                        </div>
                                        <div className="visualizer">
                                            <canvas ref={spectrumCanvasRef} style={{ width: "100%", height: "100%" }} />
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="quick-bar">
                            <div className="header-actions quick-left">
                                <button
                                    className={`synth-button ${isPlaying ? "synth-button-outline" : "synth-button-primary"}`}
                                    onClick={toggleSound}
                                >
                                    {isPlaying ? "Stop" : "Play"}
                                </button>
                                <button
                                    className="synth-button synth-button-secondary"
                                    onClick={randomizeParams}
                                >
                                    Randomize
                                </button>
                                <button
                                    className="synth-button synth-button-outline"
                                    onClick={copyShareLink}
                                >
                                    Copy Link
                                </button>
                                <button
                                    className="synth-button synth-button-outline"
                                    onClick={panicAll}
                                >
                                    Panic
                                </button>
                            </div>
                            <div className="status-row quick-right">
                                <span className="status-pill">Limiter: On</span>
                                <span className="status-pill">Mode: {soundParams.voiceMode}</span>
                                <span className="status-pill">Arp: {soundParams.arpEnabled ? "On" : "Off"}</span>
                                <span className="status-pill">Seq: {soundParams.seqEnabled ? "On" : "Off"}</span>
                                <span className="status-pill">Octave: {keyboardOctave}</span>
                                {statusMessage && <span className="status-pill">{statusMessage}</span>}
                            </div>
                        </div>

                        <div className="controls-stack">
                            <div className="controls-grid matrix">
                                <div className="control-section sound accent-orange">
                                    <div className="control-title">Sound + Voices</div>

                                <div className="control-container knob-grid">
                                    <KnobControl
                                        label="Frequency"
                                        valueLabel={formatFrequency(soundParams.frequency)}
                                        value={freqToSlider(soundParams.frequency)}
                                        min={0}
                                        max={1}
                                        step={0.001}
                                        onChange={(e) => updateParam("frequency", sliderToFreq(parseFloat(e.target.value)))}
                                    />
                                    <KnobControl
                                        label="Harmonics"
                                        valueLabel={`${getHarmonicsCount(soundParams.complexity)} voices`}
                                        value={soundParams.complexity}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("complexity", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Detune"
                                        valueLabel={`${soundParams.detune.toFixed(1)} cents`}
                                        value={soundParams.detune}
                                        min={-30}
                                        max={30}
                                        step={0.5}
                                        onChange={(e) => updateParam("detune", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Unison"
                                        valueLabel={`${soundParams.unisonCount} voices`}
                                        value={soundParams.unisonCount}
                                        min={1}
                                        max={5}
                                        step={1}
                                        onChange={(e) => updateParam("unisonCount", parseInt(e.target.value, 10))}
                                    />
                                    <KnobControl
                                        label="Unison Spread"
                                        valueLabel={`${soundParams.unisonSpread.toFixed(1)} cents`}
                                        value={soundParams.unisonSpread}
                                        min={0}
                                        max={40}
                                        step={0.5}
                                        onChange={(e) => updateParam("unisonSpread", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Sub Level"
                                        valueLabel={formatPercentage(soundParams.subLevel)}
                                        value={soundParams.subLevel}
                                        min={0}
                                        max={0.8}
                                        step={0.01}
                                        onChange={(e) => updateParam("subLevel", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Noise Level"
                                        valueLabel={formatPercentage(soundParams.noiseLevel)}
                                        value={soundParams.noiseLevel}
                                        min={0}
                                        max={0.5}
                                        step={0.01}
                                        onChange={(e) => updateParam("noiseLevel", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Glide"
                                        valueLabel={formatSeconds(soundParams.glide)}
                                        value={soundParams.glide}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("glide", parseFloat(e.target.value))}
                                    />
                                </div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>Waveform</span>
                                        <span className="mono">{soundParams.waveform}</span>
                                    </div>
                                    <div className="pill-group">
                                        {WAVEFORMS.map((wave) => (
                                            <button
                                                key={wave}
                                                className={`pill ${soundParams.waveform === wave ? "active" : ""}`}
                                                onClick={() => updateParam("waveform", wave)}
                                            >
                                                {wave}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>Voice Mode</span>
                                        <span className="mono">{soundParams.voiceMode}</span>
                                    </div>
                                    <div className="pill-group">
                                        {VOICE_MODES.map((mode) => (
                                            <button
                                                key={mode}
                                                className={`pill ${soundParams.voiceMode === mode ? "active" : ""}`}
                                                onClick={() => updateParam("voiceMode", mode)}
                                            >
                                                {mode}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                                </div>

                                <div className="control-section envelope accent-lilac">
                                <div className="control-title">Envelope</div>

                                <div className="control-container knob-grid">
                                    <KnobControl
                                        label="Attack"
                                        valueLabel={formatSeconds(soundParams.attack)}
                                        value={soundParams.attack}
                                        min={0.005}
                                        max={1.5}
                                        step={0.005}
                                        onChange={(e) => updateParam("attack", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Decay"
                                        valueLabel={formatSeconds(soundParams.decay)}
                                        value={soundParams.decay}
                                        min={0.02}
                                        max={2}
                                        step={0.01}
                                        onChange={(e) => updateParam("decay", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Sustain"
                                        valueLabel={formatPercentage(soundParams.sustain)}
                                        value={soundParams.sustain}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("sustain", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Release"
                                        valueLabel={formatSeconds(soundParams.release)}
                                        value={soundParams.release}
                                        min={0.02}
                                        max={3}
                                        step={0.01}
                                        onChange={(e) => updateParam("release", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Velocity"
                                        valueLabel={formatPercentage(soundParams.velocityAmount)}
                                        value={soundParams.velocityAmount}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("velocityAmount", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Filter Env"
                                        valueLabel={formatPercentage(soundParams.filterEnvAmount)}
                                        value={soundParams.filterEnvAmount}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("filterEnvAmount", parseFloat(e.target.value))}
                                    />
                                </div>
                                </div>

                                <div className="control-section filterfx accent-blue">
                                <div className="control-title">Filter + Drive</div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>Filter Type</span>
                                    </div>
                                    <div className="pill-group">
                                        {FILTER_TYPES.map((type) => (
                                            <button
                                                key={type}
                                                className={`pill ${soundParams.filterType === type ? "active" : ""}`}
                                                onClick={() => updateParam("filterType", type)}
                                            >
                                                {type}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className="control-container knob-grid">
                                    <KnobControl
                                        label="Cutoff"
                                        valueLabel={formatFrequency(soundParams.filterCutoff)}
                                        value={cutoffToSlider(soundParams.filterCutoff)}
                                        min={0}
                                        max={1}
                                        step={0.001}
                                        onChange={(e) => updateParam("filterCutoff", sliderToCutoff(parseFloat(e.target.value)))}
                                    />
                                    <KnobControl
                                        label="Resonance"
                                        valueLabel={`Q ${soundParams.filterResonance.toFixed(2)}`}
                                        value={soundParams.filterResonance}
                                        min={0.1}
                                        max={18}
                                        step={0.1}
                                        onChange={(e) => updateParam("filterResonance", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Drive"
                                        valueLabel={formatPercentage(soundParams.drive)}
                                        value={soundParams.drive}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("drive", parseFloat(e.target.value))}
                                    />
                                </div>
                                </div>

                                <div className="control-section modulation accent-teal">
                                <div className="control-title">Modulation</div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>LFO</span>
                                    </div>
                                    <div className="pill-group">
                                        <button
                                            className={`pill ${soundParams.lfoEnabled ? "active" : ""}`}
                                            onClick={() => updateParam("lfoEnabled", !soundParams.lfoEnabled)}
                                        >
                                            {soundParams.lfoEnabled ? "Enabled" : "Disabled"}
                                        </button>
                                    </div>
                                </div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>LFO Wave</span>
                                        <span className="mono">{soundParams.lfoWaveform}</span>
                                    </div>
                                    <div className="pill-group">
                                        {WAVEFORMS.map((wave) => (
                                            <button
                                                key={wave}
                                                className={`pill ${soundParams.lfoWaveform === wave ? "active" : ""}`}
                                                onClick={() => updateParam("lfoWaveform", wave)}
                                            >
                                                {wave}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>LFO Target</span>
                                        <span className="mono">{soundParams.lfoTarget}</span>
                                    </div>
                                    <div className="pill-group">
                                        {LFO_TARGETS.map((target) => (
                                            <button
                                                key={target}
                                                className={`pill ${soundParams.lfoTarget === target ? "active" : ""}`}
                                                onClick={() => updateParam("lfoTarget", target)}
                                            >
                                                {target}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>Mod Wheel Target</span>
                                        <span className="mono">{soundParams.modWheelTarget}</span>
                                    </div>
                                    <div className="pill-group">
                                        {MOD_TARGETS.map((target) => (
                                            <button
                                                key={target}
                                                className={`pill ${soundParams.modWheelTarget === target ? "active" : ""}`}
                                                onClick={() => updateParam("modWheelTarget", target)}
                                            >
                                                {target}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className="control-container knob-grid">
                                    <KnobControl
                                        label="LFO Rate"
                                        valueLabel={`${soundParams.lfoRate.toFixed(2)} Hz`}
                                        value={soundParams.lfoRate}
                                        min={0.1}
                                        max={20}
                                        step={0.1}
                                        onChange={(e) => updateParam("lfoRate", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="LFO Depth"
                                        valueLabel={formatPercentage(soundParams.lfoDepth)}
                                        value={soundParams.lfoDepth}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("lfoDepth", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Mod Wheel"
                                        valueLabel={formatPercentage(soundParams.modWheel)}
                                        value={soundParams.modWheel}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("modWheel", parseFloat(e.target.value))}
                                    />
                                </div>
                                </div>
                            </div>

                            <div className="controls-grid matrix">
                                <div className="control-section fx accent-yellow">
                                <div className="control-title">FX</div>

                                <div className="control-container knob-grid">
                                    <KnobControl
                                        label="Reverb"
                                        valueLabel={formatPercentage(soundParams.reverb)}
                                        value={soundParams.reverb}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("reverb", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Chorus Mix"
                                        valueLabel={formatPercentage(soundParams.chorusMix)}
                                        value={soundParams.chorusMix}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("chorusMix", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Chorus Rate"
                                        valueLabel={`${soundParams.chorusRate.toFixed(2)} Hz`}
                                        value={soundParams.chorusRate}
                                        min={0.1}
                                        max={6}
                                        step={0.1}
                                        onChange={(e) => updateParam("chorusRate", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Chorus Depth"
                                        valueLabel={formatPercentage(soundParams.chorusDepth)}
                                        value={soundParams.chorusDepth}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("chorusDepth", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Delay Mix"
                                        valueLabel={formatPercentage(soundParams.delayMix)}
                                        value={soundParams.delayMix}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("delayMix", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Delay Time"
                                        valueLabel={`${soundParams.delayTime.toFixed(2)}s`}
                                        value={soundParams.delayTime}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("delayTime", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Delay Feedback"
                                        valueLabel={formatPercentage(soundParams.delayFeedback)}
                                        value={soundParams.delayFeedback}
                                        min={0}
                                        max={0.85}
                                        step={0.01}
                                        onChange={(e) => updateParam("delayFeedback", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Bit Mix"
                                        valueLabel={formatPercentage(soundParams.bitMix)}
                                        value={soundParams.bitMix}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("bitMix", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Bit Depth"
                                        valueLabel={`${soundParams.bitDepth} bits`}
                                        value={soundParams.bitDepth}
                                        min={4}
                                        max={16}
                                        step={1}
                                        onChange={(e) => updateParam("bitDepth", parseInt(e.target.value, 10))}
                                    />
                                    <KnobControl
                                        label="Bit Reduce"
                                        valueLabel={`${soundParams.bitReduce}x`}
                                        value={soundParams.bitReduce}
                                        min={1}
                                        max={20}
                                        step={1}
                                        onChange={(e) => updateParam("bitReduce", parseInt(e.target.value, 10))}
                                    />
                                    <KnobControl
                                        label="Stereo Width"
                                        valueLabel={formatPercentage(soundParams.stereoWidth)}
                                        value={soundParams.stereoWidth}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("stereoWidth", parseFloat(e.target.value))}
                                    />
                                </div>
                                </div>

                                <div className="control-section arp accent-teal">
                                <div className="control-title">Arpeggiator</div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>Mode</span>
                                        <span className="mono">{soundParams.arpEnabled ? "On" : "Off"}</span>
                                    </div>
                                    <div className="pill-group">
                                        <button
                                            className={`pill ${soundParams.arpEnabled ? "active" : ""}`}
                                            onClick={() => updateParam("arpEnabled", !soundParams.arpEnabled)}
                                        >
                                            {soundParams.arpEnabled ? "Enabled" : "Disabled"}
                                        </button>
                                    </div>
                                </div>

                                <div className="control-container knob-grid">
                                    <KnobControl
                                        label="Tempo"
                                        valueLabel={`${Math.round(soundParams.arpRate)} BPM`}
                                        value={soundParams.arpRate}
                                        min={40}
                                        max={220}
                                        step={1}
                                        disabled={!soundParams.arpEnabled}
                                        onChange={(e) => updateParam("arpRate", parseFloat(e.target.value))}
                                    />
                                </div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>Pattern</span>
                                    </div>
                                    <div className="pill-group">
                                        {ARP_PATTERNS.map((pattern) => (
                                            <button
                                                key={pattern}
                                                className={`pill ${soundParams.arpPattern === pattern ? "active" : ""}`}
                                                onClick={() => updateParam("arpPattern", pattern)}
                                                disabled={!soundParams.arpEnabled}
                                            >
                                                {pattern}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                                </div>

                                <div className="control-section sequencer accent-blue">
                                <div className="control-title">Sequencer</div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>Enabled</span>
                                        <span className="mono">{soundParams.seqEnabled ? "On" : "Off"}</span>
                                    </div>
                                    <div className="pill-group">
                                        <button
                                            className={`pill ${soundParams.seqEnabled ? "active" : ""}`}
                                            onClick={() => updateParam("seqEnabled", !soundParams.seqEnabled)}
                                        >
                                            {soundParams.seqEnabled ? "Enabled" : "Disabled"}
                                        </button>
                                    </div>
                                </div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>Length</span>
                                        <span className="mono">{soundParams.seqLength} steps</span>
                                    </div>
                                    <div className="pill-group">
                                        {[8, 16].map((length) => (
                                            <button
                                                key={length}
                                                className={`pill ${soundParams.seqLength === length ? "active" : ""}`}
                                                onClick={() => updateParam("seqLength", length)}
                                            >
                                                {length}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div className="control-container">
                                    <div className="control-label">
                                        <span>Hold</span>
                                    </div>
                                    <div className="pill-group">
                                        <button
                                            className={`pill ${soundParams.seqHold ? "active" : ""}`}
                                            onClick={() => updateParam("seqHold", !soundParams.seqHold)}
                                        >
                                            {soundParams.seqHold ? "On" : "Off"}
                                        </button>
                                    </div>
                                </div>

                                <div className="control-container knob-grid">
                                    <KnobControl
                                        label="Rate"
                                        valueLabel={`${Math.round(soundParams.seqRate)} BPM`}
                                        value={soundParams.seqRate}
                                        min={40}
                                        max={220}
                                        step={1}
                                        onChange={(e) => updateParam("seqRate", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Gate"
                                        valueLabel={formatPercentage(soundParams.seqGate)}
                                        value={soundParams.seqGate}
                                        min={0.1}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("seqGate", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Swing"
                                        valueLabel={formatPercentage(soundParams.seqSwing)}
                                        value={soundParams.seqSwing}
                                        min={0}
                                        max={0.5}
                                        step={0.01}
                                        onChange={(e) => updateParam("seqSwing", parseFloat(e.target.value))}
                                    />
                                    <KnobControl
                                        label="Probability"
                                        valueLabel={formatPercentage(soundParams.seqProbability)}
                                        value={soundParams.seqProbability}
                                        min={0}
                                        max={1}
                                        step={0.01}
                                        onChange={(e) => updateParam("seqProbability", parseFloat(e.target.value))}
                                    />
                                </div>

                                <div className="step-grid">
                                    {soundParams.seqSteps.slice(0, soundParams.seqLength).map((step, index) => (
                                        <button
                                            key={`${index}-${step}`}
                                            className={`step-button ${step === null ? "off" : "active"}`}
                                            onClick={() => updateSeqSteps(index)}
                                        >
                                            {step === null ? "--" : step}
                                        </button>
                                    ))}
                                </div>
                                </div>

                                <div className="control-section presets accent-peach">
                                <div className="control-title">Presets + Utility</div>

                                <div className="control-container">
                                    <div className="preset-row">
                                        <input
                                            className="input"
                                            type="text"
                                            placeholder="Preset name"
                                            value={presetName}
                                            onChange={(e) => setPresetName(e.target.value)}
                                        />
                                        <button className="synth-button synth-button-primary" onClick={handlePresetSave}>
                                            Save
                                        </button>
                                    </div>
                                </div>

                                <div className="control-container">
                                    <input
                                        className="input"
                                        type="text"
                                        placeholder="Tags (comma-separated)"
                                        value={presetTags}
                                        onChange={(e) => setPresetTags(e.target.value)}
                                    />
                                </div>

                                <div className="control-container">
                                    <input
                                        className="input"
                                        type="text"
                                        placeholder="Filter presets"
                                        value={presetFilter}
                                        onChange={(e) => setPresetFilter(e.target.value)}
                                    />
                                </div>

                                <div className="control-container">
                                    <div className="preset-row">
                                        <select
                                            className="input"
                                            value={selectedPreset}
                                            onChange={(e) => setSelectedPreset(e.target.value)}
                                        >
                                            <option value="">Select preset</option>
                                            {filteredPresets.map((preset) => (
                                                <option key={preset.name} value={preset.name}>
                                                    {preset.name}{preset.tags?.length ? ` [${preset.tags.join(", ")}]` : ""}
                                                </option>
                                            ))}
                                        </select>
                                        <button className="synth-button synth-button-secondary" onClick={handlePresetLoad}>
                                            Load
                                        </button>
                                        <button className="synth-button synth-button-outline" onClick={handlePresetDelete}>
                                            Delete
                                        </button>
                                    </div>
                                </div>

                                <div className="control-container">
                                    <div className="preset-row">
                                        <button className="synth-button synth-button-secondary" onClick={exportPresets}>
                                            Export
                                        </button>
                                        <button
                                            className="synth-button synth-button-secondary"
                                            onClick={() => fileInputRef.current?.click()}
                                        >
                                            Import
                                        </button>
                                        <button
                                            className={`synth-button ${soundParams.performanceMode ? "synth-button-primary" : "synth-button-outline"}`}
                                            onClick={() => updateParam("performanceMode", !soundParams.performanceMode)}
                                        >
                                            {soundParams.performanceMode ? "Perf On" : "Perf Off"}
                                        </button>
                                        <button
                                            className={`synth-button ${soundParams.midiEnabled ? "synth-button-primary" : "synth-button-outline"}`}
                                            onClick={toggleMidi}
                                        >
                                            {soundParams.midiEnabled ? "MIDI On" : "MIDI Off"}
                                        </button>
                                    </div>
                                    <input
                                        ref={fileInputRef}
                                        type="file"
                                        accept="application/json"
                                        style={{ display: "none" }}
                                        onChange={importPresets}
                                    />
                                </div>

                                <div className="control-container">
                                    <div className="knob-grid">
                                        <KnobControl
                                            label="Export Audio"
                                            valueLabel={`${exportDuration}s WAV`}
                                            value={exportDuration}
                                            min={1}
                                            max={MAX_EXPORT_DURATION}
                                            step={1}
                                            onChange={(e) => setExportDuration(parseInt(e.target.value, 10))}
                                        />
                                    </div>
                                    <div className="preset-row">
                                        <button
                                            className="synth-button synth-button-secondary"
                                            onClick={exportAudio}
                                            disabled={isExporting}
                                        >
                                            {isExporting ? "Rendering..." : "Export WAV"}
                                        </button>
                                        <span className="mono">Includes release within length.</span>
                                    </div>
                                </div>
                                </div>
                            </div>

                            <div className="controls-grid">
                                <div className="control-section keyboard accent-yellow">
                                <div className="control-title">Keyboard + Help</div>
                                <div className="control-container">
                                    <div className="control-label">
                                        <span>Keys</span>
                                        <span className="mono">A S D F G H J K</span>
                                    </div>
                                    <div className="control-label">
                                        <span>Octave</span>
                                        <span className="mono">{keyboardOctave}</span>
                                    </div>
                                    <div className="preset-row">
                                        <button
                                            className="synth-button synth-button-secondary"
                                            onClick={() => setKeyboardOctave((prev) => clamp(prev - 1, 1, 7))}
                                        >
                                            Octave -
                                        </button>
                                        <button
                                            className="synth-button synth-button-secondary"
                                            onClick={() => setKeyboardOctave((prev) => clamp(prev + 1, 1, 7))}
                                        >
                                            Octave +
                                        </button>
                                    </div>
                                    <div className="mono">Use Z / X to shift octaves. Poly mode lets you hold notes.</div>
                                </div>
                                <details className="help-panel">
                                    <summary>Quick tips</summary>
                                    <p>Start at low volume. Reverb and drive stack quickly.</p>
                                    <p>Sequencer and arpeggiator are mutually exclusive.</p>
                                    <p>Use MIDI CC1 to control the mod wheel.</p>
                                </details>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById("synth-root"));
        root.render(<SoundSynthesizer />);
    </script>
</body>
</html>
